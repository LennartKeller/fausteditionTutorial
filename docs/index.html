<!doctype html>
<html>
    <head>
		<meta charset="utf-8">
		<title>Faustedition Tutorial</title>
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
		<!--<link rel="stylesheet" href="js/highlight/styles/default.css">
		<script src="js/highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();
		</script>-->
        <link href="js/prism.css" rel="stylesheet" />
        <script src="js/prism.js"></script>
		<style>
				summary::-webkit-details-marker {
		  display: none
		}

		summary:after {
		  content: "+";
		  float: left;
		  margin-right: 5px;
		}

		details[open] summary:after {
		  content: "-";
		}
		</style>
    </head>
	
    <body>
        <h1 class="container"><center><b>XML-Tutorial</b></center></h1>
		<div class="container">
			<div class="page-header">
			<h3><b>Inhaltsverzeichnis</b></h3>
			<nav>
			<ul>
			  <li><a href="#1">Grundlegendes</a></li>
			  <li><a href="#2">XQuery</a></li>
			  <li><a href="#3">Python</a></li>
			  <li><a href="#4">Links</a></li>
			</ul>
			</nav>
			</div>
		<div>
<!-- GRUNDLEGENDES ab hier-->
		<div id="1" class="container">
			<div class="page-header">
				<h3><b>Grundlegendes</b></h3>
			</div>
		<div>
			<p>Im Folgenden wird Ihnen anhand von zwei Beispielen erklärt, wie Sie außerhalb der Faustedition selbständig mit den zur Verfügung stehenden XML-Dateien der Handschriften arbeiten können und somit tiefer gehende Forschungsfragen klären können. Momentan stehen Ihnen die Codes zu einer XQuery- und einer Python-Variante zur Verfügung. Weitere Codes werden folgen. Dieses Tutorial richtet sich sowohl an Programmierlaien als auch an Leute mit Programmiervorkenntnissen. </p>
			<p>Sie können auch selbst Codes einreichen, um anderen die Forschung zu erleichtern: <a href="Platzhalter" target="_blank">Formular zur Einreichung von selbsterstellten Programmen</a></p>
			<p>Wählen Sie <a href="platzhalter" target="_blank">hier</a> eine Handschrift aus und laden Sie die XML-Dateien herunter.</p>
			<p>Für XQuery--Beispiel brauchen Sie Folgendes: xQuery Editor (z.B. <a href="https://www.oxygenxml.com/xml_editor/download_oxygenxml_editor.html">oXygen</a>), Transformationsprozessor (z.B. Saxon; in Oxygen implementiert)</p>
			<p>Für Python-Beispiel brauchen Sie Folgendes: <a href="https://www.python.org/downloads/" target="_blank">Python</a>, lxml-Bibliothek (pip install lxml)
		</div>
		</div>
		
		
<!-- XQUERY-BEISPIEL ab hier-->
		<div id="2" class="container">
			<div class="page-header">
				<h3><b>XQuery-Beispiel</b></h3>
			</div>
		</div>
		<div class="container">
		<div class="panel-heading"><h4>Schreiber und ihre Varianten</h4></div>
		Mit diesem Programm können Sie auf einen Blick in den jeweiligen Handschriften herausfinden, welche Schreiber es gibt und welche Varianten ihnen zugeordnet werden. Dies wird mit der Abfragesprache XQuery erreicht.
		<br/>
		<div class="panel-heading">Tutorial für Anfänger:</div>
			<ol>
				<li><p>Laden Sie die XML-Dateien <a href="platzhalter" target="_blank">hier</a> herunter und verschieben Sie sie in einen leeren Ordner.</p></li>
				<li><p>Laden Sie die Datei mit dem XQuery-Code <a href="platzhalter" target="_blank">hier</a> herunter.</p></li>
				<li><p>Öffnen Sie das XQuery-Dokument mit Oxygen.</p></li>
				<li><p>Drücken Sie in Oxygen Strg+Umschalt+C, um ein Transformations-Szenario zu konfigurieren.</p></li>
				<li><p>Erstellen Sie eine neue XQuery-Transformation.</p></li>
				<li><p>Im Feld XML URL: suchen Sie ihre gewünschte Handschriften-Datei aus.</p></li>
				<li><p>Unter dem Reiter Ausgangsdatei: entfernen Sie den Haken bei „Als Sequenz darstellen“ und geben Sie den Speicherort der HTML-Datei mit „.html“-Endung ein.</p></li>
				<li><p>Drücken Sie auf „OK“ und dann auf „Speichern und schließen“.</p></li>
				<li><p>Drücken Sie Strg+Umschalt+T, um das Transformations-Szenario auszuwenden. Nun ist eine fertige HTML-Datei im von Ihnen ausgewählten Ordner verfügbar. Diese kann mit einem beliebigen Browser geöffnet werden.</p></li>
				
			</ol>
		
		<br/>

<!-- XQUERY-CODE --> 
		<details><summary><b>Erläuterung des Quellcodes für Fortgeschrittene</b></summary>
			<div class="panel-body">
			Die Funktionen im Prolog sind von der angegebenen URL übernommen:
				<pre><code class=„language-xquery“>declare namespace functx = "http://www.functx.com";</code></pre>
			</div>
			<div class="panel-body">Schneidet den Anfang eines strings aus, bis der übergebene regex matched:
			<pre><code class=„language-xquery“>declare function functx:substring-before-match
( $arg as xs:string? ,
    $regex as xs:string )  as xs:string {

   tokenize($arg,$regex)[1]
 } ;</code></pre></div>
		<!--copypaste-element:
			<div class="panel-body">
			Erklärung
				<pre>Code</pre>
			</div> -->
			<div class="panel-body">
			Schneidet das Ende eines strings aus, ab dem match mit dem übergebenem regex:
				<pre><code class=„language-xquery“>declare function functx:substring-after-match
  ( $arg as xs:string? ,
    $regex as xs:string )  as xs:string? {

   replace($arg,concat('^.*?',$regex),'')
 } ;</code></pre>
			</div>
			<div class="panel-body">
			Liste mit allen handNote-Elementen wird in $list gespeichert:
				<pre><code class=„language-xquery“>let $liste := //handNote</pre>
			</code></div>
			<div class="panel-body">
			Sammelt alle vorkommenden IDs der Schreiber aus den Elementen:
				<pre><code class=„language-xquery“>let $wIDcollection := for $i in $list/functx:substring-before-match(data(@xml:id), '_') return $i</code></pre>
			</div>
			<div class="panel-body">
			Eliminiert Dopplungen:
				<pre><code class=„language-xquery“>let $wIDlist := for $i in fn:distinct-values($wIDcollection) return $i</code></pre>
			</div>
			<div class="panel-body">
			Iteriert über Liste der Schreiber-IDs:
				<pre><code class=„language-xquery“>for $currentWID in $wIDlist </code></pre>
			</div>
			<div class="panel-body">
			Generiert einen &lt;p/>-Block für jeden Schreiber mit Attributen Typ und Schreiber-ID:
				<pre><code class=„language-xquery“>&lt;p type="writer" xml:id="{$currentWID}"></code></pre>
			</div>
			<div class="panel-body">
			Liste mit allen Elementen, die sich auf den aktuellen Schreiber beziehen:
				<pre><code class=„language-xquery“>let $writerList := for $i in $list where /functx:substring-before-match($i/data(@xml:id), '_')=$currentWID return $i </code></pre>
			</div>
			<div class="panel-body">
			Liste mit den Schreibernamen aus allen relevanten Elementen:
				<pre><code class=„language-xquery“>let $currentWriter := for $i in $writerList/functx:substring-before-match(text(), '\s\(') return $i</code></pre>
			</div>
			<div class="panel-body">
			Eliminiert Dopplungen:
				<pre><code class=„language-xquery“>let $writer := for $i in fn:distinct-values($currentWriter) return $i</code></pre>
			</div>
			<div class="panel-body">
			Sammelt alle vorkommenden IDs der Varianten aus den aktuell relevanten Elementen:
				<pre><code class=„language-xquery“>let $vIDcollection := for $i in $writerList/functx:substring-after-match(data(@xml:id), '_') return $i</code></pre>
			</div>
			<div class="panel-body">
			Iteriert über Liste der Varianten-IDs:
				<pre><code class=„language-xquery“>for $currentVID in $vIDcollection</code></pre>
			</div>
			<div class="panel-body">
			Generiert einen Listeneintrag für jede Variante mit Attributen Typ und Varianten-ID:
				<pre><code class=„language-xquery“>&lt;li type="variant" xml:id="{$currentVID}"></code></pre>
			</div>
			<div class="panel-body">
			Ordnet Elemente der aktuellen Varianten ID zu:
				<pre><code class=„language-xquery“>let $variantList := for $i in $list where /functx:substring-after-match($i/data(@xml:id), '_')=$currentVID return $i</code></pre>
			</div>
			<div class="panel-body">
			Liest die Variantenbezeichnung aus Element aus:
				<pre><code class=„language-xquery“>let $currentVariant := for $i in $variantList/functx:substring-before-match(functx:substring-after-match(text(), '\s+\('), '\)') return $i</code></pre>
			</div>
			<div class="panel-body">
			Eliminiert Dopplungen:
				<pre><code class=„language-xquery“>let $variant := fn:distinct-values($currentVariant)</code></pre>
			</div>
			<div class="panel-body">
			Schreibt diese in den Listeneintrag:
				<pre><code class=„language-xquery“>return $variant</code></pre>
			</div>
			</details>
			<br/>
			<div class="panel-footer">
				<a href = "https://github.com/LennartKeller/faustedition_referat" target="_blank">Hier erhalten Sie die Datei mit dem vollständigen Code</a>
			</div>
		</div>
		
		
		
<!-- PYTHON-BEISPIEL ab hier-->
		<div id="3" class="container">
			<div class="page-header">
				<h3><b>Python-Beispiel</b></h3>
			</div>
		</div>
		<div class="container">
				<div class="panel-heading"><h5>Warum Python?</h5></div>
				<p>Python ist eine frei verfügbare, flexible Programmiersprache, die relativ leicht zu erlenen ist.
					Obwohl sie als Skriptsprache konzipiert wurde, werden verschiedene Programierparadigmen, wie Objektorientierung oder funktioanle Elemente unterstützt.
					Da es auch möglich ist diese Stile zu mischen wird ein hohes Maß ein Freiheit garantiert.
					Durch den Zwang sein Programm durch Einrückungen zu strukturieren, wird außerdem die Lesbarkeit des Codes automatisch verbessert.
					Aufgrund dieser Eigentschaften und der einfachen zu erlernenden und knappen Syntax ist Python auch für Quereinsteiger interessant, da die Einstiegshürden im Vergleich zu anderen Programmiersprachen sehr niedrig sind.
					Aufgrund ihrer Popularität existieren heute für beinahe jeden Anwendungsfall (meist kostenlose) Bibliotheken die den Funktionsumfang der Sprache beliebig erweitern.
					Diese lassen sich über den integrierten Packetmanager pip sehr einfach installieren. 
					In den folgenden Beispielen wird die Bibliothek lxml verwendet, um die XML-Daten der Edition zu verarbeiten.
					Da lxml nicht zum Standardumfang einer Python-Installation gehört muss sie mit dem Kommandozeilenbefehl <code class="language-bash">$ pip install lxml</code> installiert werden.

				</p>
			<div class="panel-heading"><h4>Auslesen der Handshift-Daten</h4></div>
				<p>Innerhalb der Transkripte sind die einzelnen handschriftlichen Abschnitte durch das TEI-Element handShift gekennzeichnet.
				 Dieses zeigt an,  dass ab hier der Text bis zum nächsten Auftreten eines handShift-Elements aus der Feder
				 des im @new-Attribut spezifizierten Schreibers ist. Der Wert dieses Attributes ist konform der xml:id aus den handNote-Elemente im Header,
				 so dass eine eindeutige Zuordnung der Abschnitte zu Schreiber und Schreibvariante möglich ist.</p>
				 <p>Nicht nur aus philologischer Sicht ist ein Auslesen dieser Daten interessant, sondern auch da die Datenstruktur eine 
				 kleine Herausforderung darstellt  - die handShift-Elemente sind leer, enthalten also keine Kindelemente. 
				 Die eigentlichen Daten der handShift-Einheit bilden also keinen Teilbaum des handShifts-Elements, 
				 den man einfach per XPath adressieren und auslesen könnte.
				 Im folgenden Beispiel werden diese Daten ausgelesen und in einer sehr einfachen Art verarbeitet und mit bereits bestehenden Daten aggregiert.</p>
				 <p>Das folgende Skript kann grob in 3 Abschnitte gegliedert werden, die eigene Teilaufgaben darstellen:</p>
				<ol>
					 <li>Definition von einfachen Hilfsklassen, in denen die Daten später gespeichert werden.
					 => Dies hat den Vorteil, dass im weiteren Programmablauf nicht mehr mit Listen hantiert werden muss, bei denen man auf die Daten nur
					 über einen "nicht sprechenden" Index zugreifen kann.
					 </li>
					 <li>Auslesen der gesuchten Daten aus mehreren XML-Dateien mithilfe der beiden Bibliotheken glob und lxml. 
					 ACHTUNG: lxml gehört nicht zum Standardumfang einer Python-Installation, kann aber einfach mit : 'pip install lxml' nachinstalliert werden.
					 </li>
					 <li>Im letzten Schritt werden die Daten dann in die Ergebnis-Datei aus dem XQuery-Beispiel integriert.
					 => Dies führt jedoch dazu, dass diese Datei relativ groß und unübersichtlich wird. Jedoch kann damit gut zeigen,
					 wie einfach sich mithilfe von lxml XML-Dateien modifizieren lassen.</li>
				 </ol>
			<br/>
			<details><summary><b>Quellcode</b></summary>
			<div class="panel-body">
				<pre><code class="language-python">
from lxml import etree
import glob

# Datenklassen

class Namespace:
    """
        Klasse um alle den Namen eines Namensraum zu kapseln
    """
    def __init__(self, name, uri):  
        """
        Konstruktor
            :param name: Bezeichnung des Namesraum (wird später im namespace-dict von lxml als key verwendet)
            :param uri: URI des Namenraum
        """   
        self.name = name
        self.uri = uri
    
    def __str__(self):
        """
            Stringausgabe nach der Konvention für Namensraumprefixe von lxml.Element-Strings
        """
        return '{' + self.uri + '}'

class Handshift:
    """
        Klasse um alle Daten einer handShift-Einheit zu kapseln und zu verarbeiten.
    """
    def __init__(self, source_doc, element_list):
        """
        Konstruktor
            :param source_doc: Name des Quelldokuments in dem die handShift-Einheit gefunden wurde
            :param element_list: Liste aller Elemente der handShift-Einheit, das erste Element der Liste muss das handShift-Element sein, mit dem gestart wird
        """
        # benötigte Namensräume der XML-Dokumente
        self.tei_ns = Namespace('tei', 'http://www.tei-c.org/ns/1.0')
        self.genetic_edition_ns = Namespace('geneticEdition', 'http://www.tei-c.org/ns/geneticEditions')
        self.faustedition_ns = Namespace('faustedition', 'http://www.faustedition.net/ns')
        
        # Falls das erste Element der übergebenen Elementenliste kein handShift-Element ist wird ein Fehler geworfen
        if element_list[0].tag != str(self.tei_ns) + 'handShift':
            raise Exception('First element has to be tei:handShift')
        
        self.source_doc = source_doc
        self.handShift = element_list[0]
        self.new_attrib = self.handShift.attrib['new'][1:]
        # die new-Werte haben die Form "writer_id_variantid" oder "writer_id_variantid_variantid"
        # deshalb wird bei dem ersten Unterstrich geteilt
        # wenn keine variantid vergeben wurde, enthalten sie nur die writer_id
        if "_" in self.new_attrib:
            ids = self.new_attrib.split('_', 1)
            self.writer_id = ids[0]
            self.variant_id = ids[1] 
        else:
            self.writer_id = self.new_attrib
            self.variant_id = ''        
        self.content = element_list[1:]
        

    def get_text(self, text_elements=[]):
        """
        Gibt den Text, des handShifts Abschnitts zurück, dafür werden die ge:line Elemente ausgewertet
            :param text_elements=[]: optional, zusätliche Elemente, deren Text auch ausgewertet werden soll
        """   
        string = ''
        # Sonderfall:
        # Falls  sich das handShift-Element in einem Element befindet, das Text enhält muss dieses auch noch ausgelesen werden,
        # da das lxml-Datenmodel keine Textknoten kennt, sondern den Text als Attribut interpretiert
        try:
            handShift_parent = next(self.handShift.iterancestors())
            if handShift_parent:
                text = handShift_parent.xpath('text()')
                if len(text) > 0:
                    string += text[0]
        except StopIteration:
            pass
        text_elements.append(str(self.genetic_edition_ns) + 'line')

        # Iteration über alle Element des handShifts-Abschnitts
        for i in self.content:
            # falls das Element für den Text berücksichtigt wird und auch tatsächlich Text enthält, wird dieser an den Ergebnisstring angehängt
            if i.tag in text_elements and i.text:              
                string += i.text + '\n'
        return string
    
    def __repr__(self):
        """
        Eindeutige Stringrepräsentation der Objektinstanz
        """   
        return super().__repr__() + '\n' + self.source_doc + '\n' + self.writer_id + '\n' + str(self.content)

# Begin des eigentlichen Programmablaufs
if __name__ == '__main__':
    
    # Definition der Namensräume
    tei_ns = Namespace('tei', 'http://www.tei-c.org/ns/1.0')
    genetic_edition_ns = Namespace('geneticEdition', 'http://www.tei-c.org/ns/geneticEditions')
    faustedition_ns = Namespace('faustedition', 'http://www.faustedition.net/ns')

    # lxml-methoden benötigen die Namensräume als dictionary
    namespaces = {
        # falls der TEI-Namespace, der default-namespace sein soll:
        # None: tei_ns.uri,
        tei_ns.name: tei_ns.uri,
        genetic_edition_ns.name: genetic_edition_ns.uri,
        faustedition_ns.name: faustedition_ns.uri
    }
    
    # rekurisves Durchsuchen aller Unterordner des transcripts Verzeichnisses nach xml-Dateien
    files = glob.glob('../Referat/xml/transcript/**/*.xml', recursive=True)

    result = []

    for f in files:

        # einige Dokumente enthalten fehlerhafte xml:id Attribute und können nicht geparst werden
        # in diesem Fall wird eine Fehlermeldung ausgegeben
        try:
            doc = etree.parse(f)
        except etree.XMLSyntaxError as e:
            print('WARNING: Could not parse file {}.\n{}\n'.format(f, str(e)))
            continue
        
        # überspringe den aktuellen Schleifendurchlauf, falls das Dokument kein handShift Element enthält
        if not doc.xpath('//tei:handShift', namespaces=namespaces):
            continue

        # der doc_iterator enthält alle Elemente des Dokuments in der Textreihenfolge
        doc_iterator = doc.iter()
        
        # das Done-Objekt wird der next-Funktion übergeben, damit diese keinen StopIteration Fehler wirft, wenn der Iterator "leer" ist
        # dies hat den Vorteil, dass man keine Fehlerbehandlung implementieren muss
        done = object()
        
        # das erste Element des Iteratorsa
        elem = next(doc_iterator, done)
        
        # leere Liste wird später die handShift-Abschnitte als sublists enhalten
        total = []

        # in dieser Schleife wird durch das Element iteriert
        while elem is not done:
            # falls das aktuelle Element ein handShift-Element ist
            if elem.tag == str(tei_ns) + 'handShift':
                # initialisiert eine die Liste content mit diesem Element
                content = [elem]
                elem = next(doc_iterator, done)
                # diese Schleife wird solange durchlaufen, wie das aktuelle Element kein handShift-Element ist
                # dabei wird das aktuelle Element an die content-Liste angehängt
                while elem is not done and elem.tag != str(tei_ns) + 'handShift':
                    content.append(elem)
                    elem = next(doc_iterator, done)
                # handShift-Abschnitt wird dem Gesamtergebniss angehänt
                total.append(content) 
            else:
                elem = next(doc_iterator, done)

        for sublist in total:
            result.append(Handshift(f, sublist))

# Verknüpfen der mit den Daten der Schreibvarianten nach Autor

# Einlesen der Ergebnisses aus Tutorial 1
writer_doc = etree.parse('writerid_variantid_attributes.xml')

# Vorverarbeitungsschritt, jedes li-Element wird ein leeres ul-Element anghängt,
# in das später die Dateinamen geschrieben werden
for li in writer_doc.xpath('//tei:li', namespaces=namespaces):
    li.append(etree.Element(etree.QName(tei_ns.uri, 'ul'), type='file_list'))

# Iteration über alle handShift Objekte aus dem ersten Programmteil
for handshift in result:
    # Suchen des p-Elements im html das writer_id Attribut des aktuellen Handshift Objekt ist
    p_elem = writer_doc.find('//tei:p[@wID="{}"]'.format(handshift.writer_id), namespaces=namespaces)
    
    # falls ein solches gefunden wurde
    if p_elem is not None:
        
        # Suchen des Listenelement mit der akutellen varianten_id
        if handshift.variant_id:
            list_elem = p_elem.find('.//tei:li[@vID="{}"]'.format(handshift.variant_id), namespaces=namespaces)
        
        else:
            # wenn keine variant_id exisitert, wurde die writer_id verwendet
            list_elem = p_elem.find('.//tei:li[@vID="{}"]'.format(handshift.writer_id), namespaces=namespaces)
        # Test ob ein Listenelement gefunden wurde
        if list_elem is not None:
            # Anhängen des Listeneintrags mit dem Dateipfad, falls ein solcher noch nicht existiert
            if not list_elem.xpath('.//tei:li[text()="{}"]'.format(handshift.source_doc), namespaces=namespaces):
                new_li = etree.Element(etree.QName(tei_ns.uri, 'li'), type='file')
                new_li.text = handshift.source_doc
                list_elem.find('.//tei:ul', namespaces=namespaces).append(new_li)


    else:
        print('No entry with wID = {} was found.'.format(handshift.writer_id))

# für xhtml, das vom Broswer verarbeitet werden kann muss die Ausgabe Datei als kanonisches XML geschrieben werden.
writer_doc.write_c14n('Python_Tutorial_Result.html')
				</code></pre>
			</div>
			</details>
			<br/>
			<div class="panel-footer">
				<a href = "https://github.com/LennartKeller/faustedition_referat" target="_blank">Hier erhalten Sie die Datei mit dem vollständigen Code</a>
			</div><br/>
		</div>
		<div id="4" class="container">
			<div class="page-header">
				<h3><b>Links</b></h3>
			</div>
			<div class="container"> 
			<p><a href="Platzhalter">XML-Dateien</a></p>
			<p><a href="Platzhalter">Programmeinreichung</a></p>
			<p><a href="https://www.python.org/downloads/">Python</a></p>
			<p><a href="https://notepad-plus-plus.org/download/v7.5.6.html">Notepad++</a></p>
			<p><a href="https://www.oxygenxml.com/xml_editor/download_oxygenxml_editor.html">Oxygen Trial</a></p>
			<!-- <p><a href="">Weitere Links</a><p>-->
			<br/>
			</div>
		</div>
    </body>
</html>