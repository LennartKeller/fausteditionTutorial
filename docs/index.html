<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<title>Faustedition Tutorial</title>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" />
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
	<!--<link rel="stylesheet" href="js/highlight/styles/default.css">
		<script src="js/highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();
		</script>-->
	<link href="js/prism.css" rel="stylesheet" />
	<script src="js/prism.js"></script>
	<style>
		summary::-webkit-details-marker {
			display: none
		}

		summary:after {
			content: "+";
			float: left;
			margin-right: 5px;
		}

		details[open] summary:after {
			content: "-";
		}
	</style>
</head>

<body>
	<h1 class="container">
		<center>
			<b>XML-Tutorial</b>
		</center>
	</h1>
	<div class="container">
		<div class="page-header">
			<h3>
				<b>Inhaltsverzeichnis</b>
			</h3>
			<nav>
				<ul>
					<li>
						<a href="#1">Grundlegendes</a>
					</li>
					<li>
						<a href="#2">XQuery</a>
					</li>
					<li>
						<a href="#3">Python</a>
					</li>
					<li>
						<a href="#4">Links</a>
					</li>
				</ul>
			</nav>
		</div>
		<div>
			<!-- GRUNDLEGENDES ab hier-->
			<div id="1" class="container">
				<div class="page-header">
					<h3><b>Grundlegendes</b></h3>
				</div>
			<div>
				<p>Im Folgenden wird Ihnen anhand von zwei Beispielen erklärt, wie Sie außerhalb der Faustedition selbständig mit den zur Verfügung stehenden XML-Dateien der Handschriften arbeiten und somit tiefer gehende Forschungsfragen klären können. Die digitale Faustedition bietet möglichst viele Wege, um Forschungsfragen zu beantworten, kann aber aufgrund der Vielfalt dieser nicht auf jede spezifische Möglichkeit eingehen. Alternativen stehen dem Benutzer daher zur selbständigen Erarbeitung zur Verfügung. Dazu wird der XML-Code hinter den Handschriften offengelegt und so eine offene Kommunikation ermöglicht. Diese offene Kommunikation wird durch das <a href="Platzhalter" target="_blank">Formular zur Einreichung von selbsterstellten Programmen</a> gefördert. Dort können Sie eigene Programme einreichen und damit anderen das Forschen zu Ihrer Fragestellung erleichtern. Diese werden geprüft und anschließend auf der Website eingebunden.</p>
				<p>Um die Einarbeitung in die XML-Dateien zu vereinfachen, soll Ihnen dies Tutorial zeigen, wie Sie mit ihnen umgehen und anhand dessen zielführend ihre spezifischen Fragen beantworten können. Das geschieht mithilfe von zwei Beispiel-Lösungen. Dort werden Ihnen die Programmcodes, Erläuterungen dazu, Hintergrundinformationen zu den verwendeten Sprachen und Schwierigkeiten bei der Problemlösung geboten. Momentan stehen Ihnen die Codes zu einer XQuery- und einer Python-Variante zur Verfügung. Weitere Codes werden folgen.</p>
				<div class="panel-heading"><h4>Voraussetzungen:</h4></div>
				<p>Um Forschungsfragen selbständig zu klären, werden die zu erforschenden Objekte benötigt. Diese Handschriftendaten finden Sie <a href="platzhalter" target="_blank">hier</a>. Dort sind sowohl die textuellen als auch die dokumentarischen Transkripte aufgeführt. Die Dateien können einzeln oder zusammen heruntergeladen werden. Um mit den Handschriften arbeiten zu können, braucht es ein Verständnis für die Datenstruktur.</p>
				<p>Ausgehend vom dokumentarischen Transkript kann eine grobe Übersicht zur ersten Orientierung gegeben werden. Es finden sich im TEI-Header allgemeine Informationen über Titel (titleStmt), Veröffentlichung (publicationStmt), Quellennachweis (sourceDesc) und die Handschriften mit ihren IDs im "handNotes"-Element. Das "xml:id"-Attribut innerhalb der "handNote"-Tags stellt die abgekürzte Form der Varianten dar. Beispielsweise steht "g_tr_lat" für den Schreiber (g/Goethe), das verwendete Schreibmittel (t/Tinte), die Schriftfarbe (r/rotbraun) und die Schriftart (lat/Latein). Auf diese handNotes wird weiter unten, wo der Text steht, mithilfe des handShift-Elements refereiert. Nach Varianten werden die Änderungen, Änderungszeiten und die Zuständigen dafür aufgeführt. Zwischen TEI-Header und dem Dokument wird das Faksimile mit der entsprechenden URL angezeigt. Im "ge:document"-Element wird der Text dargestellt, unterteilt in vier Zonen. Die "zone"-Elemente beinhalten Attribute, die die Lage des Textes grob bestimmen. Diese Attribute folgen dem Schema "f:Richtung1-Richtung2", wobei "Richtung2" die auschlaggebende Richtung ist. Steht in einer "zone" also das Attribut "f:bottom-top", so liegt der Text innerhalb dieser Zone oben. Der Haupttext wird durch das Attribut "type="main"" definiert. "ge:line" zeigt Zeilen an. Innerhalb dieses Elementes stellt das "rend"-Attribut die Ausrichtung dar. Zum vertieften Verständnis der Datenstruktur dient die Dokumentation. Da diese sehr umfangreich ist, kann sie hier nicht in voller Gänze dargestellt werden. Die vollständige Dokumentation der XML-Datenstruktur kann <a href="platzhalter" target="_blank">hier</a> nachgelesen werden.</p>
				<p>Für das XQuery-Beispiel brauchen Sie Folgendes: xQuery Editor (z.B. <a href="https://www.oxygenxml.com/xml_editor/download_oxygenxml_editor.html">oXygen</a>), Transformationsprozessor (z.B. Saxon; in Oxygen implementiert)</p>
				<p>Für das Python-Beispiel brauchen Sie Folgendes: <a href="https://www.python.org/downloads/" target="_blank">Python</a>, lxml-Bibliothek (pip install lxml)
			</div>
			</div>


			<!-- XQUERY-BEISPIEL ab hier-->
			<div id="2" class="container">
				<div class="page-header">
					<h3>
						<b>XQuery-Beispiel</b>
					</h3>
				</div>
			</div>
			<div class="container">
				<div class="panel-heading">
					<h4>Schreiber und ihre Varianten</h4>
				</div>
				Mit diesem Programm können Sie auf einen Blick in den jeweiligen Handschriften herausfinden, welche Schreiber es gibt und
				welche Varianten ihnen zugeordnet werden. Dies wird mit der Abfragesprache XQuery erreicht.
				<br/>
				<div class="panel-heading">Tutorial für Anfänger:</div>
				<ol>
					<li>
						<p>Laden Sie die XML-Dateien
							<a href="platzhalter" target="_blank">hier</a> herunter und verschieben Sie sie in einen leeren Ordner.</p>
					</li>
					<li>
						<p>Laden Sie die Datei mit dem XQuery-Code
							<a href="platzhalter" target="_blank">hier</a> herunter.</p>
					</li>
					<li>
						<p>Öffnen Sie das XQuery-Dokument mit Oxygen.</p>
					</li>
					<li>
						<p>Drücken Sie in Oxygen Strg+Umschalt+C, um ein Transformations-Szenario zu konfigurieren.</p>
					</li>
					<li>
						<p>Erstellen Sie eine neue XQuery-Transformation.</p>
					</li>
					<li>
						<p>Im Feld XML URL: suchen Sie ihre gewünschte Handschriften-Datei aus.</p>
					</li>
					<li>
						<p>Unter dem Reiter Ausgangsdatei: entfernen Sie den Haken bei „Als Sequenz darstellen“ und geben Sie den Speicherort
							der HTML-Datei mit „.html“-Endung ein.</p>
					</li>
					<li>
						<p>Drücken Sie auf „OK“ und dann auf „Speichern und schließen“.</p>
					</li>
					<li>
						<p>Drücken Sie Strg+Umschalt+T, um das Transformations-Szenario auszuwenden. Nun ist eine fertige HTML-Datei im von Ihnen
							ausgewählten Ordner verfügbar. Diese kann mit einem beliebigen Browser geöffnet werden.</p>
					</li>

				</ol>

				<br/>

				<!-- XQUERY-CODE -->
				<details>
					<summary>
						<b>Erläuterung des Quellcodes für Fortgeschrittene</b>
					</summary>
					<div class="panel-body">
						Die Funktionen im Prolog sind von der angegebenen URL übernommen:
						<pre><code class=„language-xquery“>declare namespace functx = "http://www.functx.com";</code></pre>
					</div>
					<div class="panel-body">Schneidet den Anfang eines strings aus, bis der übergebene regex matched:
						<pre><code class=„language-xquery“>declare function functx:substring-before-match
( $arg as xs:string? ,
    $regex as xs:string )  as xs:string {

   tokenize($arg,$regex)[1]
 } ;</code></pre>
					</div>
					<!--copypaste-element:
			<div class="panel-body">
			Erklärung
				<pre>Code</pre>
			</div> -->
					<div class="panel-body">
						Schneidet das Ende eines strings aus, ab dem match mit dem übergebenem regex:
						<pre><code class=„language-xquery“>declare function functx:substring-after-match
  ( $arg as xs:string? ,
    $regex as xs:string )  as xs:string? {

   replace($arg,concat('^.*?',$regex),'')
 } ;</code></pre>
					</div>
					<div class="panel-body">
						Liste mit allen handNote-Elementen wird in $list gespeichert:
						<pre><code class=„language-xquery“>let $liste := //handNote</pre>
						</code>
					</div>
					<div class="panel-body">
						Sammelt alle vorkommenden IDs der Schreiber aus den Elementen:
						<pre><code class=„language-xquery“>let $wIDcollection := for $i in $list/functx:substring-before-match(data(@xml:id), '_') return $i</code></pre>
					</div>
					<div class="panel-body">
						Eliminiert Dopplungen:
						<pre><code class=„language-xquery“>let $wIDlist := for $i in fn:distinct-values($wIDcollection) return $i</code></pre>
					</div>
					<div class="panel-body">
						Iteriert über Liste der Schreiber-IDs:
						<pre><code class=„language-xquery“>for $currentWID in $wIDlist </code></pre>
					</div>
					<div class="panel-body">
						Generiert einen &lt;p/>-Block für jeden Schreiber mit Attributen Typ und Schreiber-ID:
						<pre><code class=„language-xquery“>&lt;p type="writer" xml:id="{$currentWID}"></code></pre>
					</div>
					<div class="panel-body">
						Liste mit allen Elementen, die sich auf den aktuellen Schreiber beziehen:
						<pre><code class=„language-xquery“>let $writerList := for $i in $list where /functx:substring-before-match($i/data(@xml:id), '_')=$currentWID return $i </code></pre>
					</div>
					<div class="panel-body">
						Liste mit den Schreibernamen aus allen relevanten Elementen:
						<pre><code class=„language-xquery“>let $currentWriter := for $i in $writerList/functx:substring-before-match(text(), '\s\(') return $i</code></pre>
					</div>
					<div class="panel-body">
						Eliminiert Dopplungen:
						<pre><code class=„language-xquery“>let $writer := for $i in fn:distinct-values($currentWriter) return $i</code></pre>
					</div>
					<div class="panel-body">
						Sammelt alle vorkommenden IDs der Varianten aus den aktuell relevanten Elementen:
						<pre><code class=„language-xquery“>let $vIDcollection := for $i in $writerList/functx:substring-after-match(data(@xml:id), '_') return $i</code></pre>
					</div>
					<div class="panel-body">
						Iteriert über Liste der Varianten-IDs:
						<pre><code class=„language-xquery“>for $currentVID in $vIDcollection</code></pre>
					</div>
					<div class="panel-body">
						Generiert einen Listeneintrag für jede Variante mit Attributen Typ und Varianten-ID:
						<pre><code class=„language-xquery“>&lt;li type="variant" xml:id="{$currentVID}"></code></pre>
					</div>
					<div class="panel-body">
						Ordnet Elemente der aktuellen Varianten ID zu:
						<pre><code class=„language-xquery“>let $variantList := for $i in $list where /functx:substring-after-match($i/data(@xml:id), '_')=$currentVID return $i</code></pre>
					</div>
					<div class="panel-body">
						Liest die Variantenbezeichnung aus Element aus:
						<pre><code class=„language-xquery“>let $currentVariant := for $i in $variantList/functx:substring-before-match(functx:substring-after-match(text(), '\s+\('), '\)') return $i</code></pre>
					</div>
					<div class="panel-body">
						Eliminiert Dopplungen:
						<pre><code class=„language-xquery“>let $variant := fn:distinct-values($currentVariant)</code></pre>
					</div>
					<div class="panel-body">
						Schreibt diese in den Listeneintrag:
						<pre><code class=„language-xquery“>return $variant</code></pre>
					</div>
				</details>
				<br/>
				<div class="panel-footer">
					<a href="https://github.com/LennartKeller/faustedition_referat" target="_blank">Hier erhalten Sie die Datei mit dem vollständigen Code</a>
				</div>
			</div>



			<!-- PYTHON-BEISPIEL ab hier-->
			<div id="3" class="container">
				<meta name="Author" content="Jan Keller">
				<div class="page-header">
					<h3>
						<b>Python-Beispiel</b>
					</h3>
				</div>
			</div>
			<div class="container">
				<div class="panel-heading">
					<h5>Warum Python?</h5>
				</div>
				<p>Python ist eine frei verfügbare, flexible Programmiersprache, die relativ leicht zu erlernen ist. Obwohl sie als Skriptsprache
					konzipiert wurde, unterstützt sie verschiedene Programierparadigmen, wie Objektorientierung oder funktioanle Elemente.
					Da es auch möglich ist diese Stile zu mischen wird ein hohes Maß ein Freiheit garantiert. Durch den Zwang sein Programm
					durch Einrückungen zu strukturieren, wird die Lesbarkeit des Codes automatisch verbessert. Aufgrund dieser Eigenschaften
					und der knappen und einfach zu erlernenden Syntax ist Python auch für Quereinsteiger interessant, da die Einstiegshürden
					im Vergleich zu anderen Programmiersprachen sehr niedrig sind. Aufgrund ihrer Popularität existieren heute für beinahe
					jeden Anwendungsfall (fast immer kostenlose) Bibliotheken, die den Funktionsumfang der Sprache beinahe beliebig erweitern. Diese
					lassen sich meist sehr einfach über den integrierten Packetmanager pip installieren.
			
				</p>
				<div class="panel-heading">
					<h5>Python und XML</h5>
				</div>
				<p>XML ist nicht nur im Umfeld der Digitalen Editionen ein etabliertes Format zum Datenaustausch. Deshalb bietet Python
					verschiedene Wege XML-Daten auszulesen und zu schreiben. Zuerst zu erwähnen wären die DOM-, SAX- oder ElementTree-API, die Python
					standardmäßig mitbringt.
				</p>
	
				<p>Die DOM-API ermöglicht es ein XML-Dokument als Document-Object-Model abzubilden und zu verabeiten. Hierfür wird das gesamte
					Dokument als Baum in den Hauptspeicher geladen. Dies hat den Vorteil, dass man zu jedem Zeitpunkt auf alle Daten zugreifen
					kann. Der Speicherbedarf dieser Methode kann aber bei großen Datenmengen recht schnell wachsen. Der DOM-Standard ist
					in verschiedenen Versionen vom W3C spezifiziert und diese Python Implementation unterstützt die Level 1 und 2 Spezifikationen.<br/>
					Für weitere Informationen besuchen Sie die
					<a href="https://docs.python.org/3.7/library/xml.dom.html">offizielle Python-Dokumentation</a>.
				</p>
				<p>In Fällen in denen der Speicherbedarf eine Rolle spielt kann es sinnvoller sein die SAX-API zu verwenden. SAX steht für
					Simple API for XML und behandelt behandelt XML als einen Datenstrom der sequentiell eingelesen wird. Man kann nun bestimmte
					Events definieren zum Beispiel beim Auftreten eines bestimmten Elements während des Einlesens ausgelöst werden. Innerhalb
					dieser Events findet dann die Verarbeitung statt. Ein Nachteil dieser Methode ist aber, dass man so den Kontext der Daten nur eingeschränkt, das bedeutet nur innerhalb des Events überblicken kann.
					Dafür ist der Speicherbedarf geringer als beim DOM.<br/>
					Für weitere Informationen besuchen Sie die <a href="https://docs.python.org/3.7/library/xml.sax.html">offizielle Python-Dokumentation</a>.
				</p>
				<p>Die ElementTree-API verfolgt das Ziel möglichst einfach und effizient  in der Benutzung zu sein. Die Grundlage bilden zwei Datentypen: ElemenTree und Element.
					Der ElementTree repräsentiert die Daten - ähnlich dem DOM - in einer Baumstruktur und stellt Methoden bereit durch diesen zu navigieren.
					Konzeptuell ist dieser Datentyp und seine Funktionen an der Listen-Implementation von Python angelehnt.
					Der Datentyp Element repräsentiert logischerweise die einzelnen Elemente des ElementTree. Hier versucht man sich an den Konventionen von der Dictionaries von Python zu orientieren.
					Des weiteren bietet die ElementTree-API eine funktionell stark eingeschränkte XPath-Implementation an, die eine Teilmenge der Syntax unterstützt.
					Um die Performance zu verbessern sind Teile der API in C geschrieben.<br/>
					Für weitere Informationen besuchen Sie die <a href="https://docs.python.org/3.7/library/xml.etree.elementtree.html">offizielle Python-Dokumentation</a>.

				</p>
				<p>
					Nachteile  der ersten beiden Ansätze sind neben der Tatsache, dass in beiden Fällen viel "Handarbeit" nötig ist, um Ergebnisse zu erzielen, die eher schlechte Verarbeitungsgeschwindigkeit <!-- Performance-->,
					sowie das Fehlen XML spezifischer Features XPath und XSLT. Die ElementTree-API hingegen ist zwar schnell zu erlernen und man erzielt aufgrund der komfortablen Methoden schnell zu Ergebnissen
					aber die eingeschränkte XPath-Unterstützung und das Fehlen weiterer XML-spezifischer Technologien wie XSLT lassen auch hier noch Spielraum zum Wünschen übrig.<br/>
					Die Bibliothek lxml versucht hier Abhilfe zu schaffen. Sie verbindet die Performance der in C geschriebenen Bibliotheken libxml2 und libxslt, die intern verwendet werden, mit einer weitesgehenden
					Kompatibilität zur benutzerfreundlichen ElementTree-API bei den bereitgestellten Methoden. Daneben unterstützt sie XSLT und XPath in Version 1.0.<br/>
					In den folgenden Beispielen wird lxml verwendet, um die XML-Daten der Edition zu verarbeiten. Da sie nicht zum Standardumfang einer Python-Installation
					gehört muss sie, falls nicht bereits vorhanden, über Kommandozeile mit <code class="language-bash">$ pip install lxml</code> installiert werden.
				</p>
				<div class="panel-heading"><h6>Exkurs: Besonderheiten des Datenmodel von lxml</h6></div>
				<>Da es im folgenden Beispiel um das Auslesen von der eigentlichen Texte der handShift Abschnitte geht, ist es an dieser Stelle nötig den Eigenheiten des lxml-Datenmodels 
					in Bezug auf Textdaten einige Worte zu widmen. Die XML-Spezifikation sieht eigentlich
					vor Text als Kindelemente (oder Blätter um in der Baumterminolgie zu bleiben) der Elemente die ihn enthalten zu behandeln.<br/>
					Angenommmen wir haben dieses simple XML-Dokuement:
					<pre><code class="language-xml">
<textarea>
<dokument>
	<zeile>Hallo <unklar>daf<vielleicht>s</vielleicht></unklar> ist ein Satz.</zeile>
</dokument>
</textarea>
</code></pre>
				Wenden wir nun folgenden XPath-Ausdruck:
<pre>
	<code class="language-xquery">
//zeile/text()
	</code>
</pre>
					auf das Dokument an so erhalten wir eine Sequenz mit den Strings:
<pre>
<code class="language-xquery">
"Hallo",
"ist ein Satz."
</code>
</pre>
					Während man nach dem Ausführen dieses Python-Codes:
<pre>
<code class="language-python">
<textarea>
from lxml import etree

doc = etree.fromstring("""
<dokument>
	<zeile>Hallo <unklar>daf<vielleicht>s</vielleicht></unklar> ist ein Satz.</zeile>
</dokument>
""")
elem = doc.find("zeile")
print(elem.text)
</textarea>
</code>
</pre>

					lediglich dieses Resultat bekommt.
<pre>
<code class="language-python">
"Hallo"
</code>
</pre>
					Aber wo ist das Ende des Satzes geblieben?
				</p>
				<div class="panel-heading">
					<h4>Auslesen der Handshift-Daten</h4>
				</div>
				<p>Innerhalb der Transkripte sind die einzelnen handschriftlichen Abschnitte durch das TEI-Element handShift gekennzeichnet.
					Dieses zeigt an, dass ab hier der Text bis zum nächsten Auftreten eines handShift-Elements aus der Feder des im @new-Attribut
					spezifizierten Schreibers ist. Der Wert dieses Attributes ist konform der xml:id aus den handNote-Elemente im Header,
					so dass eine eindeutige Zuordnung der Abschnitte zu Schreiber und Schreibvariante möglich ist.</p>
				<p>Nicht nur aus philologischer Sicht ist ein Auslesen dieser Daten interessant, sondern auch da die Datenstruktur eine
					kleine Herausforderung darstellt - die handShift-Elemente sind leer, enthalten also keine Kindelemente. Die eigentlichen
					Daten der handShift-Einheit bilden also keinen Teilbaum des handShifts-Elements, den man einfach per XPath adressieren
					und auslesen könnte. Im folgenden Beispiel werden diese Daten ausgelesen und in einer sehr einfachen Art verarbeitet
					und mit bereits bestehenden Daten aggregiert.</p>
				<p>Das folgende Skript kann grob in 3 Abschnitte gegliedert werden, die eigene Teilaufgaben darstellen:</p>
				<ol>
					<li>Definition von einfachen Hilfsklassen, in denen die Daten später gespeichert werden.<br/> 
						⇒ Dies hat den Vorteil, dass im
						weiteren Programmablauf nicht mehr mit Listen hantiert werden muss, bei denen man auf die Daten nur über einen "nicht
						sprechenden" Index zugreifen kann.
					</li>
					<li>Auslesen der gesuchten Daten aus mehreren XML-Dateien mithilfe der beiden Bibliotheken glob und lxml.
					</li>
					<li>Im letzten Schritt werden die Daten dann in die Ergebnis-Datei aus dem XQuery-Beispiel integriert.<br/>
						⇒ Dies führt jedoch
						dazu, dass diese Datei relativ groß und unübersichtlich wird. Jedoch kann damit gut zeigen, wie einfach sich mithilfe
						von lxml XML-Dateien modifizieren lassen.</li>
				</ol>
				<br/>
				<details>
					<summary>
						<b>Quellcode</b>
					</summary>
					<div class="panel-body">
						<pre><code class="language-python">
from lxml import etree
import glob

# Datenklassen

class Namespace:
    """
        Klasse um alle den Namen eines Namensraum zu kapseln
    """
    def __init__(self, name, uri):  
        """
        Konstruktor
            :param name: Bezeichnung des Namesraum (wird später im namespace-dict von lxml als key verwendet)
            :param uri: URI des Namenraum
        """   
        self.name = name
        self.uri = uri
    
    def __str__(self):
        """
            Stringausgabe nach der Konvention für Namensraumprefixe von lxml.Element-Strings
        """
        return '{' + self.uri + '}'

class Handshift:
    """
        Klasse um alle Daten einer handShift-Einheit zu kapseln und zu verarbeiten.
    """
    def __init__(self, source_doc, element_list):
        """
        Konstruktor
            :param source_doc: Name des Quelldokuments in dem die handShift-Einheit gefunden wurde
            :param element_list: Liste aller Elemente der handShift-Einheit, das erste Element der Liste muss das handShift-Element sein, mit dem gestart wird
        """
        # benötigte Namensräume der XML-Dokumente
        self.tei_ns = Namespace('tei', 'http://www.tei-c.org/ns/1.0')
        self.genetic_edition_ns = Namespace('geneticEdition', 'http://www.tei-c.org/ns/geneticEditions')
        self.faustedition_ns = Namespace('faustedition', 'http://www.faustedition.net/ns')
        
        # Falls das erste Element der übergebenen Elementenliste kein handShift-Element ist wird ein Fehler geworfen
        if element_list[0].tag != str(self.tei_ns) + 'handShift':
            raise Exception('First element has to be tei:handShift')
        
        self.source_doc = source_doc
        self.handShift = element_list[0]
        self.new_attrib = self.handShift.attrib['new'][1:]
        # die new-Werte haben die Form "writer_id_variantid" oder "writer_id_variantid_variantid"
        # deshalb wird bei dem ersten Unterstrich geteilt
        # wenn keine variantid vergeben wurde, enthalten sie nur die writer_id
        if "_" in self.new_attrib:
            ids = self.new_attrib.split('_', 1)
            self.writer_id = ids[0]
            self.variant_id = ids[1] 
        else:
            self.writer_id = self.new_attrib
            self.variant_id = ''        
        self.content = element_list[1:]
        

    def get_text(self, text_elements=[]):
        """
        Gibt den Text, des handShifts Abschnitts zurück, dafür werden die ge:line Elemente ausgewertet
            :param text_elements=[]: optional, zusätliche Elemente, deren Text auch ausgewertet werden soll
        """   
        string = ''
        # Sonderfall:
        # Falls  sich das handShift-Element in einem Element befindet, das Text enhält muss dieses auch noch ausgelesen werden,
        # da das lxml-Datenmodel keine Textknoten kennt, sondern den Text als Attribut interpretiert
        try:
            handShift_parent = next(self.handShift.iterancestors())
            if handShift_parent:
                text = handShift_parent.xpath('text()')
                if len(text) > 0:
                    string += text[0]
        except StopIteration:
            pass
        text_elements.append(str(self.genetic_edition_ns) + 'line')

        # Iteration über alle Element des handShifts-Abschnitts
        for i in self.content:
            # falls das Element für den Text berücksichtigt wird und auch tatsächlich Text enthält, wird dieser an den Ergebnisstring angehängt
            if i.tag in text_elements and i.text:              
                string += i.text + '\n'
        return string
    
    def __repr__(self):
        """
        Eindeutige Stringrepräsentation der Objektinstanz
        """   
        return super().__repr__() + '\n' + self.source_doc + '\n' + self.writer_id + '\n' + str(self.content)

# Begin des eigentlichen Programmablaufs
if __name__ == '__main__':
    
    # Definition der Namensräume
    tei_ns = Namespace('tei', 'http://www.tei-c.org/ns/1.0')
    genetic_edition_ns = Namespace('geneticEdition', 'http://www.tei-c.org/ns/geneticEditions')
    faustedition_ns = Namespace('faustedition', 'http://www.faustedition.net/ns')

    # lxml-methoden benötigen die Namensräume als dictionary
    namespaces = {
        # falls der TEI-Namespace, der default-namespace sein soll:
        # None: tei_ns.uri,
        tei_ns.name: tei_ns.uri,
        genetic_edition_ns.name: genetic_edition_ns.uri,
        faustedition_ns.name: faustedition_ns.uri
    }
    
    # rekurisves Durchsuchen aller Unterordner des transcripts Verzeichnisses nach xml-Dateien
    files = glob.glob('../Referat/xml/transcript/**/*.xml', recursive=True)

    result = []

    for f in files:

        # einige Dokumente enthalten fehlerhafte xml:id Attribute und können nicht geparst werden
        # in diesem Fall wird eine Fehlermeldung ausgegeben
        try:
            doc = etree.parse(f)
        except etree.XMLSyntaxError as e:
            print('WARNING: Could not parse file {}.\n{}\n'.format(f, str(e)))
            continue
        
        # überspringe den aktuellen Schleifendurchlauf, falls das Dokument kein handShift Element enthält
        if not doc.xpath('//tei:handShift', namespaces=namespaces):
            continue

        # der doc_iterator enthält alle Elemente des Dokuments in der Textreihenfolge
        doc_iterator = doc.iter()
        
        # das Done-Objekt wird der next-Funktion übergeben, damit diese keinen StopIteration Fehler wirft, wenn der Iterator "leer" ist
        # dies hat den Vorteil, dass man keine Fehlerbehandlung implementieren muss
        done = object()
        
        # das erste Element des Iteratorsa
        elem = next(doc_iterator, done)
        
        # leere Liste wird später die handShift-Abschnitte als sublists enhalten
        total = []

        # in dieser Schleife wird durch das Element iteriert
        while elem is not done:
            # falls das aktuelle Element ein handShift-Element ist
            if elem.tag == str(tei_ns) + 'handShift':
                # initialisiert eine die Liste content mit diesem Element
                content = [elem]
                elem = next(doc_iterator, done)
                # diese Schleife wird solange durchlaufen, wie das aktuelle Element kein handShift-Element ist
                # dabei wird das aktuelle Element an die content-Liste angehängt
                while elem is not done and elem.tag != str(tei_ns) + 'handShift':
                    content.append(elem)
                    elem = next(doc_iterator, done)
                # handShift-Abschnitt wird dem Gesamtergebniss angehänt
                total.append(content) 
            else:
                elem = next(doc_iterator, done)

        for sublist in total:
            result.append(Handshift(f, sublist))

# Verknüpfen der mit den Daten der Schreibvarianten nach Autor

# Einlesen der Ergebnisses aus Tutorial 1
writer_doc = etree.parse('writerid_variantid_attributes.xml')

# Vorverarbeitungsschritt, jedes li-Element wird ein leeres ul-Element anghängt,
# in das später die Dateinamen geschrieben werden
for li in writer_doc.xpath('//tei:li', namespaces=namespaces):
    li.append(etree.Element(etree.QName(tei_ns.uri, 'ul'), type='file_list'))

# Iteration über alle handShift Objekte aus dem ersten Programmteil
for handshift in result:
    # Suchen des p-Elements im html das writer_id Attribut des aktuellen Handshift Objekt ist
    p_elem = writer_doc.find('//tei:p[@wID="{}"]'.format(handshift.writer_id), namespaces=namespaces)
    
    # falls ein solches gefunden wurde
    if p_elem is not None:
        
        # Suchen des Listenelement mit der akutellen varianten_id
        if handshift.variant_id:
            list_elem = p_elem.find('.//tei:li[@vID="{}"]'.format(handshift.variant_id), namespaces=namespaces)
        
        else:
            # wenn keine variant_id exisitert, wurde die writer_id verwendet
            list_elem = p_elem.find('.//tei:li[@vID="{}"]'.format(handshift.writer_id), namespaces=namespaces)
        # Test ob ein Listenelement gefunden wurde
        if list_elem is not None:
            # Anhängen des Listeneintrags mit dem Dateipfad, falls ein solcher noch nicht existiert
            if not list_elem.xpath('.//tei:li[text()="{}"]'.format(handshift.source_doc), namespaces=namespaces):
                new_li = etree.Element(etree.QName(tei_ns.uri, 'li'), type='file')
                new_li.text = handshift.source_doc
                list_elem.find('.//tei:ul', namespaces=namespaces).append(new_li)


    else:
        print('No entry with wID = {} was found.'.format(handshift.writer_id))

# für xhtml, das vom Broswer verarbeitet werden kann muss die Ausgabe Datei als kanonisches XML geschrieben werden.
writer_doc.write_c14n('Python_Tutorial_Result.html')
				</code></pre>
					</div>
				</details>
				<br/>
				<div class="container">
					<p>Im nächsten Beispiel werden die Inhalte der
						<code class="language-xpath">handShift</code>-Abschnitte ausgelesen und verarbeitet. Dies wird mit Hilfe des Target-Paser-Interfaces realisiert.
						Dieses ermöglicht es, einen eigenen Parser zu implementieren, der die gewünschte Verarbeitungslogik enthält.</p>
				</div>
				<div class="panel-footer">
					<a href="https://github.com/LennartKeller/faustedition_referat" target="_blank">Hier erhalten Sie die Datei mit dem vollständigen Code</a>
				</div>
				<br/>
			</div>
			<div id="4" class="container">
				<div class="page-header">
					<h3>
						<b>Links</b>
					</h3>
				</div>
				<div class="container">
					<p>
						<a href="Platzhalter">XML-Dateien</a>
					</p>
					<p>
						<a href="Platzhalter">Programmeinreichung</a>
					</p>
					<p>
						<a href="https://www.python.org/downloads/">Python</a>
					</p>
					<p>
						<a href="https://notepad-plus-plus.org/download/v7.5.6.html">Notepad++</a>
					</p>
					<p>
						<a href="https://www.oxygenxml.com/xml_editor/download_oxygenxml_editor.html">Oxygen Trial</a>
					</p>
					<!-- <p><a href="">Weitere Links</a><p>-->
					<br/>
				</div>
			</div>
</body>

</html>