<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<title>Faustedition Tutorial</title>
	<link rel="icon" href="favicon.ico" type="image/x-icon"/>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" />
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
	<!--<link rel="stylesheet" href="js/highlight/styles/default.css">
		<script src="js/highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();
		</script>-->
	<link href="js/prism.css" rel="stylesheet" />
	<script src="js/prism.js"></script>
	<style>
		summary::-webkit-details-marker {
			display: none
		}

		summary:after {
			content: "+";
			float: left;
			margin-right: 5px;
		}

		details[open] summary:after {
			content: "-";
		}
	</style>
</head>

<body>
	<h1 class="container">
		<center>
			<b>XML-Tutorial</b>
		</center>
	</h1>
	<div class="container">
		<div class="page-header">
			<h3>
				<b>Inhaltsverzeichnis</b>
			</h3>
			<nav>
				<ul>
					<li>
						<a href="#1">Grundlegendes</a>
					</li>
					<li>
						<a href="#2">XQuery</a>
					</li>
					<li>
						<a href="#3">Python</a>
					</li>
					<li>
						<a href="#4">Links</a>
					</li>
				</ul>
			</nav>
		</div>
		<div>
			<!-- GRUNDLEGENDES ab hier-->
			<div id="1" class="container">
				<div class="page-header">
					<h3><b>Grundlegendes</b></h3>
				</div>
			<div>
				<p>Im Folgenden wird Ihnen anhand von zwei Beispielen erklärt, wie Sie außerhalb der Faustedition selbständig mit den zur Verfügung stehenden XML-Dateien der Handschriften arbeiten und somit tiefer gehende Forschungsfragen klären können. Die digitale Faustedition bietet möglichst viele Wege, um Forschungsfragen zu beantworten, kann aber aufgrund der Vielfalt dieser nicht auf jede spezifische Möglichkeit eingehen. Alternativen stehen dem Benutzer daher zur selbständigen Erarbeitung zur Verfügung. Dazu wird der XML-Code hinter den Handschriften offengelegt und so eine offene Kommunikation ermöglicht. Diese offene Kommunikation wird durch das <a href="Platzhalter" target="_blank">Formular zur Einreichung von selbsterstellten Programmen</a> gefördert. Dort können Sie eigene Programme einreichen und damit anderen das Forschen zu Ihrer Fragestellung erleichtern. Diese werden geprüft und anschließend auf der Website eingebunden.</p>
				<p>Um die Einarbeitung in die XML-Dateien zu vereinfachen, soll Ihnen dies Tutorial zeigen, wie Sie mit ihnen umgehen und anhand dessen zielführend ihre spezifischen Fragen beantworten können. Das geschieht mithilfe von zwei Beispiel-Lösungen. Dort werden Ihnen die Programmcodes, Erläuterungen dazu, Hintergrundinformationen zu den verwendeten Sprachen und Schwierigkeiten bei der Problemlösung geboten. Momentan stehen Ihnen die Codes zu einer XQuery- und einer Python-Variante zur Verfügung. Weitere Codes werden folgen.</p>
				<div class="panel-heading"><h4>Voraussetzungen:</h4></div>
				<p>Um Forschungsfragen selbständig zu klären, werden die zu erforschenden Objekte benötigt. Diese Handschriftendaten finden Sie <a href="platzhalter" target="_blank">hier</a>. Dort sind sowohl die textuellen als auch die dokumentarischen Transkripte aufgeführt. Die Dateien können einzeln oder zusammen heruntergeladen werden. Um mit den Handschriften arbeiten zu können, braucht es ein Verständnis für die Datenstruktur.</p>
				<p>Ausgehend vom dokumentarischen Transkript kann eine grobe Übersicht zur ersten Orientierung gegeben werden. Es finden sich im TEI-Header allgemeine Informationen über Titel (titleStmt), Veröffentlichung (publicationStmt), Quellennachweis (sourceDesc) und die Handschriften mit ihren IDs im "handNotes"-Element. Das "xml:id"-Attribut innerhalb der "handNote"-Tags stellt die abgekürzte Form der Varianten dar. Beispielsweise steht "g_tr_lat" für den Schreiber (g/Goethe), das verwendete Schreibmittel (t/Tinte), die Schriftfarbe (r/rotbraun) und die Schriftart (lat/Latein). Auf diese handNotes wird weiter unten, wo der Text steht, mithilfe des handShift-Elements refereiert. Nach Varianten werden die Änderungen, Änderungszeiten und die Zuständigen dafür aufgeführt. Zwischen TEI-Header und dem Dokument wird das Faksimile mit der entsprechenden URL angezeigt. Im "ge:document"-Element wird der Text dargestellt, unterteilt in vier Zonen. Die "zone"-Elemente beinhalten Attribute, die die Lage des Textes grob bestimmen. Diese Attribute folgen dem Schema "f:Richtung1-Richtung2", wobei "Richtung2" die auschlaggebende Richtung ist. Steht in einer "zone" also das Attribut "f:bottom-top", so liegt der Text innerhalb dieser Zone oben. Der Haupttext wird durch das Attribut "type="main"" definiert. "ge:line" zeigt Zeilen an. Innerhalb dieses Elementes stellt das "rend"-Attribut die Ausrichtung dar. Zum vertieften Verständnis der Datenstruktur dient die Dokumentation. Da diese sehr umfangreich ist, kann sie hier nicht in voller Gänze dargestellt werden. Die vollständige Dokumentation der XML-Datenstruktur kann <a href="platzhalter" target="_blank">hier</a> nachgelesen werden.</p>
				<p>Für das XQuery-Beispiel brauchen Sie Folgendes: XQuery Implementierung (z.B. eXist, BaseX, Saxon, Zorba). Auf Grund der Vielzahl an Nutzungsmöglichkeiten bezüglich XML-Dateien wird auf den <a href="https://www.oxygenxml.com/xml_editor/download_oxygenxml_editor.html">oXygen XML Editor</a> verwiesen, der Saxon als Transformationsprozessor eingebunden hat.</p>
				<p>Für das Python-Beispiel brauchen Sie Folgendes: <a href="https://www.python.org/downloads/" target="_blank">Python</a>, lxml-Bibliothek (pip install lxml)
			</div>
			</div>


			<!-- XQUERY-BEISPIEL ab hier-->
			<div id="2" class="container">
				<div class="page-header">
					<h3>
						<b>XQuery-Beispiel</b>
					</h3>
				</div>
			</div>
			<div class="container">
				<div class="panel-heading">
					<h4>Warum XQuery?</h4>
				</div>
					<p>
						Wenn es darum geht, spezifische Informationen aus einer Sammlung an XML-Dateien zu extrahieren, dann ist XQuery meistens erste Wahl. Die Abfragesprache für XML arbeitet mit XPath Ausdrücken als Grundlage und unterstützt somit die Baumstruktur der XML-Dateien nativ. Als XML Query Language ist XQuery 1.0 seit 2007, XQuery 3.0 seit 2014 die W3C Empfehlung, und kann mittlerweile in über 60 Implementierungen genutzt werden. Sie sind auf die verschiedensten Anwendungsbereiche ausgerichtet und bieten jeweils eigene Vorzüge. Wer nach etwas bestimmtem sucht, kann sich unter <a href="http://www.w3.org/XML/Query/#implementations" target="_blank">www.w3c.org</a> einen Überblick verschaffen.		 
					</p>
				<p>
					XQuery kann genutzt werden, um eine einzelne XML-Datei oder eine gesamte Datenbank einzulesen, zu verarbeiten, und gegebenenfalls zu einer neuen Datei zu transformieren. Im Gegensatz zu XSLT ist XQuery dabei jedoch nicht auf die Transformation ausgerichtet. Im einfachsten Fall wird das Abfrageergebnis als Sequenz (die grundlegende Datenstruktur von XQuery, ähnlich einer Liste) ausgegeben und im Editor angezeigt, oder beispielsweise als JSON-Datei gespeichert. Stattdessen kann jedoch auch eine neue XML-Datei erzeugt werden, deren Aufbau sich ganz nach den Wünschen des Nutzers richtet, da er die Baumstruktur simultan zu den Queryabschnitten im Code konstruiert.
				</p>
				<div class="panel-heading">
					<h4>Funktionsweise von XQuery</h4>
				</div>
				<div class="panel-heading">
					<h5>FLOWR-Ausdrücke</h5>
				</div>
				<p>
					Der wichtigste Bestandteil der XQuery Syntax sind die FLWOR-Ausdrücke, deren Bezeichnung sich aus den Anfangsbuchstaben von For-Schleife, Let-Variablendeklaration, Where-Bedingung, Order-Sortierreihenfolge und Return-Ausgabebefehl, zusammensetzt. 
					Sie können mit geschweiften Klammern geschachtelt werden um komplexe Anfragen zu realisieren. 
				</p>
				<div class="panel-heading">
					<h5>XPath</h5>
				</div>
				<p>
					Durch den Aufbau dieser Sprache kann (wenigstens) alles gefunden werden was mit XPath gefunden werden kann. Dabei kann XPath bereits genutzt werden, um in einzelnen XML-Dateien einfach nach Inhalten zu suchen. Außerdem wird anhand der Funktionsweise von XPath gleichzeitig das Strukturkonzept von XML-Dateien klarer. 
				</p>
				<p>
					Sobald XPath ins Spiel kommt, kann die Bezeichnung Baumstruktur der Dateien auf "Stammbaum"-struktur erweitert werden. Denn die Bezeichnungen der Verhältnisse zwischen einzelnen Bestandteilen bedienen sich eben diesem Vokabular. 
					So ist alles innerhalb des einzigartigen root-Elements ein Nachkommen (descendant) desselben. 
					Jeder Nachkommen kann wiederum weitere Kinder oder weiter entfernte Nachkommen haben. 
					Kinder mit dem selben Elternknoten sind Geschwister (following-siblings). 
					Von jedem Element im Dokument lässt sich über seine Vorfahren (ancestor) wieder die Wurzel erreichen. 
					Dies ermöglicht beinahe uneingeschränkte Navigation zwischen den Knoten und ihren Inhalten. 
					Einen vollständigen Überblick über die Funktionsweise von XPath erhalten Sie <a href="https://www.w3schools.com/xml/xpath_intro.asp" target="_blank">hier</a>.  
				</p>
				<div class="panel-body">
					Dieser Auszug einer XML-Datei ist den digitalisierten Handschriften entnommen:
					<pre><code class="language-xml">
						<textarea>
							
<ge:line xml:id="la" rend="right">
	<handShift new="#xx_bl_lat"/>
	<fw type="pageNum">20</fw>
</ge:line>
<ge:line xml:id="lb" rend="centered">
	<handShift new="#jo_t_lat"/>Ein Gartenhäuschen
</ge:line>
<ge:line xml:id="lc" rend="centered">
	<f:grLine f:orient="horiz" f:style="linear" hand="#jo_t_lat"/>
</ge:line>
							</textarea>
					</code></pre></div>
				<div class="panel-body">
					Mit diesem XPath Ausdruck werden zuerst alle Nachkommen der Wurzel gesucht, die ein handShift-Element sind.
					Davon werden die ausgewählt, deren new-Attribut das Kürzel für "John - Tinte - Latein" beeinhalten.
					Von hieraus wird zu dem Vorfahrenelement navigiert, das ein ge:line-Element ist.
					<pre><code class="language-xquery">//handShift[@new="#jo_t_lat"]//ancestor::ge:line</code></pre>
				</div>
				<div class="panel-body">Der Inhalt des gefundenen Elements wird ausgegeben: "Ein Gartenhäuschen"</div>
				<div class="panel-heading">
					<h5>Transformation - Anleitung für XQuery-Neulinge</h5>
				</div>
				<ol>
					<li>
						<p>Laden Sie die XML-Dateien
							<a href="platzhalter" target="_blank">hier</a> herunter und verschieben Sie sie in einen leeren Ordner.</p>
					</li>
					<li>
						<p>Laden Sie eine Datei mit XQuery-Code
							<a href="platzhalter" target="_blank">hier</a> herunter.</p>
					</li>
					<li>
						<p>Öffnen Sie das XQuery-Dokument mit Oxygen.</p>
					</li>
					<li>
						<p>Drücken Sie in Oxygen Strg+Umschalt+C, um ein Transformations-Szenario zu konfigurieren.</p>
					</li>
					<li>
						<p>Erstellen Sie eine neue XQuery-Transformation.</p>
					</li>
					<li>
						<p>Wenn Sie die Query als Softcode über eine einzelne Datei laufen lassen wollen: Im Feld "XML URL": suchen Sie ihre gewünschte Handschriften-Datei aus.</p>
						<p>Wenn Sie die Query als Hardcode über eine oder mehrere Dateien laufen lassen wollen: Feld "XML URL" leer lassen, der Pfad zu gewünschter Datei oder Verzeichnis muss direkt im Code der $repository-Variablen zugeordnet werden.</p>
					<li>
						<p>In beiden Fällen kann das Feld "XQuery URL" mit "${currentFileURL}" gefüllt werden, um die aktuell geöffnete Datei auszuführen.</p>
					</li>
					<li>
						<p>Unter dem Reiter Ausgangsdatei: entfernen Sie den Haken bei "Als Sequenz darstellen" und geben Sie den Speicherort
							der HTML-Datei mit ".html"-Endung ein.</p>
					</li>
					<li>
						<p>Drücken Sie auf "OK" und dann auf "Speichern und schließen".</p>
					</li>
					<li>
						<p>Drücken Sie Strg+Umschalt+T, um das Transformations-Szenario anzuwenden. Nun ist eine fertige HTML-Datei im von Ihnen
							ausgewählten Ordner verfügbar. Diese kann mit einem beliebigen Browser geöffnet werden.</p>
					</li>
					
				</ol>
			
				<div class="panel-heading">
					<h4>Schreiberhände und ihr Schreibmaterial</h4>
				</div>
				Im hier präsentierten Abfragebeispiel wird eine Liste mit zwei Gliederungsebenen erzeugt. Es finden sich alle beteiligten Schreiberhände in alphabetischer Sortierung. Unter jeder Schreiberhand sind die Kombinationen aus Schreibmaterial und Schriftart aufgelistet, die sie verwendet hat. Die Kürzel für die jeweiligen Informationen werden als Attribute in die Listenelemente geschrieben. 
				So sind sie für die Weiterverarbeitung als XML-Datei mit weiteren Abfragesprachen zugänglich, werden jedoch - als HTML-Datei transformiert - vor dem Benutzer verborgen, um die Übersichtlichkeit zu erhöhen.
				<br/>
				
				<br/>

				<!-- XQUERY-CODE -->
				<details>
					<summary>
						<b>Erläuterung des Quellcodes</b>
					</summary>
					<div class="panel-body">
						Der Prolog der XQuery Datei enthält Namespace-Deklarationen sowie Funktionen, die später vom Hauptteil aufgerufen werden können.
						Benötigte Namespaces müssen an dieser Stelle festgelegt werden, Funktionen können jedoch in eine separate Datei ausgelagert werden.
						Hier sind zunächst die Namespaces festgelegt, die in den XML-Dateien des Verzeichnisses vorkommen.
						<pre><code class="language-xquery">declare namespace f = "http://www.faustedition.net/ns";
declare namespace ge = "http://www.tei-c.org/ns/geneticEditions";
</code></pre>
					</div>
					<details><summary>Exkurs: Funktionen in eigenes Modul auslagern</summary>
					<div class="panel-body">Wenn sich die Funktionen in der gleichen Datei befinden sollen wie das ausführbare Hauptmodul der XQuery, dann wird der Namespace direkt angegeben, und die Operation der Funktion im Prolog programmiert.
						<pre><code class="language-xquery">declare namespace sns = "http://www.some_ns.com";
declare function sns:some-function ( param )
{ operation };
						</code></pre>
					</div>
					<div class="panel-body">
						Alternativ können alle Funktionen in einer Datei gespeichert werden, die eine Moduldeklaration im Prolog enthält, und keinen auszuführenden Abfragecode. Alle dort definierten Funktionen übernehmen den festgelegten Namespace.
						<pre><code class="language-xquery">module namespace my = "myModule";
declare function my:my-function (param) 
{ operation };</code>
						</pre>
					</div>
					<div class="panel-body">
						Im Hauptmodul, in dem der eigentliche Abfragecode geschrieben ist, wird dann nur das davor erstellte Modul eingebettet, um mit dem entsprechenden Namespace alle darin festgelegten Funktionen abrufen zu können. 
						<pre><code class="language-xquery">import module namespace my = "myModule" at "/myPath/myModule.xquery";</code></pre>
					</div>
					</details>
					<!--copypaste-element:
			<div class="panel-body">
			Erklärung
				<pre><code class="language-xquery"></code></pre>
			</div> -->
					<div class="panel-body">Der Anfang des übergebenen Strings wird ausgegeben, bis zu der Stelle, an der das Muster des angegebenen regulären Ausdrucks als erstes gefunden wird
						<pre><code class="language-xquery">declare function functx:substring-before-match
( $arg as xs:string? ,
    $regex as xs:string )  as xs:string {

   tokenize($arg,$regex)[1]
 } ;</code></pre></div>
					<div class="panel-body">
						Das Ende des übergebenen Strings wird ausgegeben, ab der Stelle, an der das Muster des angegebenen regulären Ausdrucks als erstes gefunden wurde
						<pre><code class="language-xquery">declare function functx:substring-after-match
  ( $arg as xs:string? ,
    $regex as xs:string )  as xs:string? {

   replace($arg,concat('^.*?',$regex),'')
 } ;</code></pre>
					</div>
					<div class="panel-body">
						Nach dem Prolog wird zuerst der Header des HTML-Dokuments konstruiert.
						In der letzten Zeile wird ein Paragraph eröffnet. Die sich öffnende, geschweifte Klammer deutet darauf hin, dass an dieser Stelle auszuführender XQuery Code den späteren Inhalt des Paragraphen füllen soll.
						<pre><code class="language-xml"><textarea>
<xhtml xmlns="http://www.w3.org/1999/xhtml" 
  xmlns:TEI="http://www.tei-c.org/ns/1.0">
<head>
    <meta http-equiv="content-type" content="text/xhtml; char set=utf-8"/>
    <title>Writers and their hands</title>
</head>
    <h2>Writers and their hands</h2>
<p>{</textarea></code></pre>
					</div>
					<div class="panel-body">
						Zunächst wird der Verzeichnis- bzw. Dateipfad mit den zu durchsuchenden Dateien angegeben. 
						<pre><code class="language-xquery">let $path := "C:/Fausteditionen/transcript/agad_warszawa/0020.xml"</code></pre>
					</div>
					<div class="panel-body">
						Die eingebaute doc-Funktion ruft die gewünschten Datei auf, sodass sie weiter verarbeitet werden kann.
						Nur wenn das TEI-Element "handNotes" existiert, ist sie für diese Abfrage brauchbar. Mit dem XPath-Operator // werden alle Nachkommen in der gesamten Datei gefunden, ist dies nicht der Fall, wird ein Error ausgegeben.
						<pre><code class="language-xquery">let $file := for $file in doc(concat('file:///',$path,'?recurse=yes')) return 
							if ($file//TEI:handNotes) then $file 
							else error( QName('', 'ElementRequest'),  "Missing required element 'handNotes'")</code></pre>
					</div>
					<div class="panel-body">
						Liste mit allen handNote-Elementen wird in $handNotes gespeichert.
						<pre><code class="language-xquery">let $handNotes := $file//TEI:handNote</pre>
						</code>
					</div>
					<div class="panel-body">
						In den xml:id-Attributen der handNotes-Elemente steht eine Kombination von Schreiber-ID und Schriftart-ID. Da diese mit Unterstrich voneinander getrennt sind, findet die Funktion alle vorkommenden IDs der Schreiber.
						<pre><code class="language-xquery">let $wIDcollection := for $writerID in $handNotes/functx:substring-before-match(data(@xml:id), '_') return $writerID</code></pre>
					</div>
					<div class="panel-body">
						Da die einzelnen Schreiber mit verschiedenen Schriftarten aufgelistet sind, ergeben sich Dopplungen wenn nur die Schreiber betrachtet werden. Die eingebaute distinct-values-Funktion eliminiert diese.
						<pre><code class="language-xquery">let $wIDs := for $wID in fn:distinct-values($wIDcollection) return $wID</code></pre>
					</div>
					<div class="panel-body">
						Für jeden Schreiber wird in einer Schleife ein Paragraph erzeugt. Dabei sind sie alphabetisch nach ihren Kürzeln sortiert, wodurch "Fremde Hand 1 (xx)" am Ende der Ausgabe landet.
						Die Schreiber-ID, über die gerade iteriert wird, wird als Attributinhalt in das Element geschrieben. Für jeden Schreiber wird danach der Querycode ausgeführt, der danach im p-Element steht.
						<pre><code class="language-xquery">for $currentWID in $wIDs     
order by $currentWID
return <textarea><p type="writer" wID="{$currentWID}"></textarea>{</code></pre>
					</div>
					<div class="panel-body">
						Generiert einen &lt;p/>-Block für jeden Schreiber mit Attributen Typ und Schreiber-ID:
						<pre><code class="language-xquery">&lt;p type="writer" xml:id="{$currentWID}"></code></pre>
					</div>
					<div class="panel-body">
						Liste mit allen Elementen, die sich auf den aktuellen Schreiber beziehen:
						<pre><code class="language-xquery">let $writerList := for $i in $list where /functx:substring-before-match($i/data(@xml:id), '_')=$currentWID return $i </code></pre>
					</div>
					<div class="panel-body">
						Liste mit den Schreibernamen aus allen relevanten Elementen:
						<pre><code class="language-xquery">let $currentWriter := for $i in $writerList/functx:substring-before-match(text(), '\s\(') return $i</code></pre>
					</div>
					<div class="panel-body">
						Eliminiert Dopplungen:
						<pre><code class="language-xquery">let $writer := for $i in fn:distinct-values($currentWriter) return $i</code></pre>
					</div>
					<div class="panel-body">
						Sammelt alle vorkommenden IDs der Style aus den aktuell relevanten Elementen:
						<pre><code class="language-xquery">let $vIDcollection := for $i in $writerList/functx:substring-after-match(data(@xml:id), '_') return $i</code></pre>
					</div>
					<div class="panel-body">
						Iteriert über Liste der Style-IDs:
						<pre><code class="language-xquery">for $currentVID in $vIDcollection</code></pre>
					</div>
					<div class="panel-body">
						Generiert einen Listeneintrag für jede Variante mit Attributen Typ und Style-ID:
						<pre><code class="language-xquery">&lt;li type="variant" xml:id="{$currentVID}"></code></pre>
					</div>
					<div class="panel-body">
						Ordnet Elemente der aktuellen Style ID zu:
						<pre><code class="language-xquery">let $variantList := for $i in $list where /functx:substring-after-match($i/data(@xml:id), '_')=$currentVID return $i</code></pre>
					</div>
					<div class="panel-body">
						Liest die Stylebezeichnung aus Element aus:
						<pre><code class="language-xquery">let $currentVariant := for $i in $variantList/functx:substring-before-match(functx:substring-after-match(text(), '\s+\('), '\)') return $i</code></pre>
					</div>
					<div class="panel-body">
						Eliminiert Dopplungen:
						<pre><code class="language-xquery">let $variant := fn:distinct-values($currentVariant)</code></pre>
					</div>
					<div class="panel-body">
						Schreibt diese in den Listeneintrag:
						<pre><code class="language-xquery">return $variant</code></pre>
					</div>
				</details>
				<br/>
				<div class="panel-footer">
					<a href="https://github.com/LennartKeller/faustedition_referat" target="_blank">Hier erhalten Sie die Datei mit dem vollständigen Code</a>
				</div>
			</div>



			<!-- PYTHON-BEISPIEL ab hier-->
			<div id="3" class="container">
				<meta name="Author" content="Jan Keller">
				<div class="page-header">
					<h3>
						<b>Python-Beispiel</b>
					</h3>
				</div>
			</div>
			<div class="container">
				<div class="panel-heading">
					<h5>Warum Python?</h5>
				</div>
				<p>Python ist eine frei verfügbare, flexible Programmiersprache, die relativ leicht zu erlernen ist. Obwohl sie als Skriptsprache
					konzipiert wurde, unterstützt sie verschiedene Programierparadigmen, wie Objektorientierung oder funktioanle Elemente.
					Da es auch möglich ist diese Stile zu mischen, wird ein hohes Maß ein Freiheit garantiert. Durch den Zwang den Quellcode
					durch Einrückungen zu strukturieren, wird die Lesbarkeit automatisch verbessert. Aufgrund dieser Eigenschaften
					und der knappen und einfach zu erlernenden Syntax ist Python auch für Quereinsteiger interessant. Die Einstiegshürden sind
					im Vergleich zu anderen Programmiersprachen sehr niedrig. Angesichts ihrer Popularität existieren heute für beinahe
					jeden Anwendungsfall (meist kostenlose) Bibliotheken, die den Funktionsumfang der Sprache beinahe beliebig erweitern. Diese
					lassen sich meist sehr einfach über den integrierten Packetmanager pip installieren.
			
				</p>
				<div class="panel-heading">
					<h5>Python und XML</h5>
				</div>
				<p>XML ist nicht nur im Umfeld der Digitalen Editionen ein etabliertes Format zum Datenaustausch. Python bietet
					verschiedene Wege XML-Daten auszulesen und zu schreiben. Zuerst zu erwähnen sind die DOM-, SAX- oder ElementTree-API, die Python
					standardmäßig mitbringt.
				</p>
	
				<p>Die DOM-API ermöglicht es ein XML-Dokument als Document-Object-Model abzubilden und zu verabeiten. Hierfür wird das gesamte
					Dokument als Baum in den Hauptspeicher geladen. Dies hat den Vorteil, dass zu jedem Zeitpunkt auf alle Daten zugegriffen werden
					kann. Der Speicherbedarf dieses Ansatzes kann aber bei großen Datenmengen recht schnell wachsen. Der DOM-Standard ist
					in verschiedenen Versionen vom W3C spezifiziert und diese Python Implementation unterstützt die Level 1 und 2 Spezifikationen.<br/>
					Für weitere Informationen besuchen Sie die
					<a href="https://docs.python.org/3.7/library/xml.dom.html">offizielle Python-Dokumentation</a>.
				</p>
				<p>In Fällen in denen der Speicherbedarf eine Rolle spielt, kann es sinnvoller sein die SAX-API zu verwenden. SAX steht für
					Simple API for XML und behandelt XML als einen Datenstrom der sequentiell eingelesen wird. Man kann nun bestimmte
					Events definieren, wie  zum Beispiel das Auftreten eines bestimmten Elements. Diese Events werden während des Einlesens ausgelöst. Innerhalb
					dieser Events findet die eigentliche Datenverarbeitung statt. Ein Nachteil dieser Methode ist aber, dass man so den Kontext der Daten
					nur eingeschränkt - das bedeutet nur innerhalb des Events - überblicken kann.
					Dafür ist der Speicherbedarf geringer als beim DOM.<br/>
					Für weitere Informationen besuchen Sie die <a href="https://docs.python.org/3.7/library/xml.sax.html">offizielle Python-Dokumentation</a>.
				</p>
				<p>Die ElementTree-API verfolgt das Ziel möglichst einfach und effizient in der Benutzung zu sein. Die Grundlage bilden zwei Datentypen: ElemenTree und Element.
					Der ElementTree repräsentiert die Daten - ähnlich dem DOM - in einer Baumstruktur und stellt Methoden bereit durch diesen zu navigieren.
					Konzeptuell ist dieser Datentyp und seine Funktionen an der Listen-Implementation von Python angelehnt.
					Der Datentyp Element repräsentiert die einzelnen Elemente des ElementTree. Hier versucht man sich an den Konventionen von der Dictionaries von Python zu orientieren.
					Des weiteren bietet die ElementTree-API eine funktionell stark eingeschränkte XPath-Implementation an, die eine Teilmenge der Syntax unterstützt.
					Um die Performance zu verbessern, sind Teile der API in C geschrieben.<br/>
					Für weitere Informationen besuchen Sie die <a href="https://docs.python.org/3.7/library/xml.etree.elementtree.html">offizielle Python-Dokumentation</a>.

				</p>
				<p>
					Nachteile  der ersten beiden Ansätze sind neben der Tatsache, dass in beiden Fällen viel "Handarbeit" nötig ist, um Ergebnisse zu erzielen, die eher schlechte Verarbeitungsgeschwindigkeit <!-- Performance-->,
					sowie das Fehlen XML spezifischer Features XPath und XSLT. Die ElementTree-API hingegen ist zwar schnell zu erlernen und man erzielt aufgrund der komfortablen Methoden schnell Ergebnisse.
					Die eingeschränkte XPath-Unterstützung und das Fehlen weiterer XML-spezifischer Technologien wie XSLT lassen aber in noch Verbesserungspotential erkennen.<br/>
					Die Bibliothek lxml versucht hier Abhilfe zu schaffen. Sie verbindet die Performance der in C geschriebenen Bibliotheken libxml2 und libxslt, die intern verwendet werden, mit einer weitesgehenden
					Kompatibilität zur benutzerfreundlichen ElementTree-API bei den bereitgestellten Methoden. Daneben unterstützt sie XSLT und XPath in Version 1.0.<br/>
					In den folgenden Beispielen wird lxml verwendet, um die XML-Daten der Edition zu verarbeiten. Da sie nicht zum Standardumfang einer Python-Installation
					gehört, muss sie, falls nicht bereits vorhanden, über Kommandozeile mit <code class="language-bash">$ pip install lxml</code> installiert werden.
				</p>
				<br/>
				<br/>

				<div class="panel-heading">
					<h5>Vorbemerkung</h5>
				</div>
					<p>
						In diesem Abschnitt ist ein Großteil der Erläuterungen in den mit <code class="language-python">#</code> gekennzeichnteten Kommentaren direkt im Quellcode zu finden.<br/>
						Dieser muss so nicht unterteilt werden, was dazu führt, dass die Einrückungen besser ersichtlich sind.
					</p>
				<div class="panel-heading">
					<h5>Auslesen der Handshift-Daten</h5>
				</div>
				<p>Innerhalb der Transkripte sind die einzelnen handschriftlichen Abschnitte durch das TEI-Element handShift gekennzeichnet.
					Dieses zeigt an, dass ab hier der Text bis zum nächsten Auftreten eines handShift-Elements aus der Feder des im @new-Attribut
					spezifizierten Schreibers ist. Der Wert dieses Attributes ist konform der xml:id aus den handNote-Elemente im Header,
					so dass eine eindeutige Zuordnung der Abschnitte zu Schreiber und Schreibvariante möglich ist.</p>
				<p>Nicht nur aus philologischer Sicht ist ein Auslesen dieser Daten interessant, sondern auch da die Datenstruktur eine
					kleine Herausforderung darstellt - die handShift-Elemente sind leer, enthalten also keine Kindelemente. Die eigentlichen
					Daten der handShift-Einheit bilden also keinen Teilbaum des handShifts-Elements, den man einfach per XPath adressieren
					und auslesen könnte. Im folgenden Beispiel werden diese Daten ausgelesen und in einer sehr einfachen Art verarbeitet
					und mit bereits bestehenden Daten aggregiert.</p>
				<p>Das folgende Skript kann grob in 3 Abschnitte gegliedert werden, die eigene Teilaufgaben darstellen:</p>
				<ol>
					<li>Definition von einfachen Hilfsklassen, in denen die Daten später gespeichert werden.<br/> 
						⇒ Dies hat den Vorteil, dass im
						weiteren Programmablauf nicht mehr mit Listen hantiert werden muss, bei denen man auf die Daten nur über einen "nicht
						sprechenden" Index zugreifen kann.
					</li>
					<li>Auslesen der gesuchten Daten aus mehreren XML-Dateien mithilfe der beiden Bibliotheken glob und lxml.
					</li>
					<li>Im letzten Schritt werden die Daten dann in die Ergebnis-Datei aus dem XQuery-Beispiel integriert.<br/>
						⇒ Dies führt jedoch
						dazu, dass diese Datei relativ groß und unübersichtlich wird. Jedoch kann damit gut gezeigt werden, wie einfach sich mithilfe
						von lxml XML-Dateien modifizieren lassen.</li>
				</ol>
				<br/>
				<details>
					<summary>
						<b>Quellcode</b>
					</summary>
					<div class="panel-body">
						<pre><code class="language-python">
from lxml import etree
import glob

# Datenklassen

class Namespace:
	"""
		Klasse um alle den Namen eines Namensraum zu kapseln
	"""
	def __init__(self, name, uri):  
		"""
		Konstruktor
			:param name: Bezeichnung des Namesraum (wird später im namespace-dict von lxml als key verwendet)
			:param uri: URI des Namenraum
		"""   
		self.name = name
		self.uri = uri
	
	def __str__(self):
		"""
		Stringausgabe nach der Konvention für Namensraumprefixe von lxml.Element-Strings
		"""
		return '{' + self.uri + '}'
	
	def __add__(self, other):
		"""
		Verkettet den Namensraumprefix mit einem beliebigen String
			:param other: String der mit dem Namesraumprefix verkettet werden soll.
		"""
		if not isinstance(other, str):
			raise TypeError("Other has to be of type str")
		return self.__str__() + other

class Handshift:
	"""
		Klasse um alle Daten einer handShift-Einheit zu kapseln und zu verarbeiten.
	"""
	def __init__(self, source_doc, element_list):
		"""
		Konstruktor
			:param source_doc: Name des Quelldokuments in dem die handShift-Einheit gefunden wurde
			:param element_list: Liste aller Elemente der handShift-Einheit, das erste Element der Liste muss das handShift-Element sein, mit dem gestart wird
		"""
		# Namensräume der XML-Dokumente
		self.tei_ns = Namespace('tei', 'http://www.tei-c.org/ns/1.0')
		self.genetic_edition_ns = Namespace('geneticEdition', 'http://www.tei-c.org/ns/geneticEditions')
		self.faustedition_ns = Namespace('faustedition', 'http://www.faustedition.net/ns')
		
		# Falls das erste Element der übergebenen Elementenliste kein handShift-Element ist wird ein Fehler geworfen
		if element_list[0].tag != str(self.tei_ns) + 'handShift':
			raise Exception('First element has to be tei:handShift')
		
		self.source_doc = source_doc
		self.handShift = element_list[0]

		# der Wert des new-Attributs hat die Form '#<writerid>_<styleid>' oder '#<writerid>_<styleid>_<stylesuffix>'
		# weshalb hier die Raute weggesch_<styleid>nitten wird und der String beim ersten Unterstrich geteilt wird
		self.new_attrib = self.handShift.attrib['new'][1:]
		if "_" in self.new_attrib:
			ids = self.new_attrib.split('_', 1)
			self.writer_id = ids[0]
			self.style_id = ids[1] 
		else:
			self.writer_id = self.new_attrib
			self.style_id = ''        
		self.content = element_list[1:]
		
	def get_text(self, text_elements=[]):
		"""
		Gibt den Text, des handShifts Abschnitts zurück, dafür werden die ge:line Elemente ausgewertet
			:param text_elements=[]: optional, zusätzliche Elemente, deren Text auch ausgewertet werden soll
		"""   
		string = ''
		# Sonderfall:
		# Falls  sich das handShift-Element in einem Element befindet, das Text enhält muss dieses auch noch ausgelesen werden,
		# da vereinfacht gesagt das lxml-Datenmodel keine Textknoten kennt, sondern den Text als Attribut interpretiert
		try:
			handShift_parent = next(self.handShift.iterancestors())
			if handShift_parent is not None:
				text = handShift_parent.xpath('text()')
				if len(text) > 0:
					for i in text:
						string += i
		except StopIteration:
			pass
		
		text_elements.append(str(self.genetic_edition_ns) + 'line')

		# Iteration über alle Element des handShifts-Abschnitts
		for i in self.content:
			# falls das Element für den Text berücksichtigt wird und auch tatsächlich Text enthält, wird dieser an den Ergebnisstring angehängt
			if i.tag in text_elements and i.text:              
				string += i.text + '\n'
		return string
	
	def __repr__(self):
		"""
		Eindeutige Stringrepräsentation der Objektinstanz
		"""   
		return super().__repr__() + '\n' + self.source_doc + '\n' + self.writer_id + '\n' + str(self.content)

# Begin des eigentlichen Programmablaufs
if __name__ == '__main__':
	
	# Definition der Namensräume
	tei_ns = Namespace('tei', 'http://www.tei-c.org/ns/1.0')
	genetic_edition_ns = Namespace('geneticEdition', 'http://www.tei-c.org/ns/geneticEditions')
	faustedition_ns = Namespace('faustedition', 'http://www.faustedition.net/ns')

	# lxml-methoden benötigen die Namensräume als dictionary
	namespaces = {
		# falls der TEI-Namespace, der default-namespace sein soll:
		# None: tei_ns.uri,
		tei_ns.name: tei_ns.uri,
		genetic_edition_ns.name: genetic_edition_ns.uri,
		faustedition_ns.name: faustedition_ns.uri
	}
	
	# rekursives Durchsuchen aller Unterordner des transcripts Verzeichnisses nach xml-Dateien
	# ACHTUNG: Der Pfad muss unter Umständen angepasst werden.
	files = glob.glob('./xml/transcript/**/*.xml', recursive=True)
	
	if not files:
		raise FileNotFoundError("Could not find any XML-Files")

	result = []

	for f in files:

		# Im Falle von Fehlern bei dem Parsen der Dokumente wird eine Fehlermeldung ausgegeben und diese Datei wird übersprungen.
		try:
			doc = etree.parse(f)
		except etree.XMLSyntaxError as e:
			print('WARNING: Could not parse file {}.\n{}\n'.format(f, str(e)))
			continue
		
		# überspringe den aktuellen Schleifendurchlauf, falls das Dokument kein handShift Element enthält
		if not doc.xpath('//tei:handShift', namespaces=namespaces):
			continue

		# der doc_iterator enthält alle Elemente des Dokuments in der Textreihenfolge
		doc_iterator = doc.iter()
		
		# das Done-Objekt wird der next-Funktion übergeben, damit diese keinen StopIteration Fehler wirft, wenn der Iterator "leer" ist
		# dies hat den Vorteil, dass man keine Fehlerbehandlung implementieren muss
		done = object()
		
		# das erste Element des Iteratorsa
		elem = next(doc_iterator, done)
		
		# leere Liste wird später die handShift-Abschnitte als sublists enhalten
		total = []

		# in dieser Schleife wird durch das Element iteriert
		while elem is not done:
			# falls das aktuelle Element ein handShift-Element ist
			if elem.tag == str(tei_ns) + 'handShift':
				# initialisiert eine die Liste content mit diesem Element
				content = [elem]
				elem = next(doc_iterator, done)
				# diese Schleife wird solange durchlaufen, wie das aktuelle Element kein handShift-Element ist
				# dabei wird das aktuelle Element an die content-Liste angehängt
				while elem is not done and elem.tag != str(tei_ns) + 'handShift':
					content.append(elem)
					elem = next(doc_iterator, done)
				# handShift-Abschnitt wird dem Gesamtergebnis angehängt
				total.append(content) 
			else:
				elem = next(doc_iterator, done)

		for sublist in total:
			result.append(Handshift(f, sublist))

	# Verknüpfen der mit den Daten der Schreibstilen nach Autor

	# Einlesen der Ergebnisses aus Tutorial 1
	writer_doc = etree.parse('writerid_variantid_attributes.xml')

	# Vorverarbeitungsschritt, jedes li-Element wird ein leeres ul-Element angehängt,
	# in das später die Dateinamen geschrieben werden
	for li in writer_doc.xpath('//tei:li', namespaces=namespaces):
		li.append(etree.Element(etree.QName(tei_ns.uri, 'ul'), type='file_list'))

	# Iteration über alle handShift Objekte aus dem ersten Programmteil
	for handshift in result:
		# Suchen des p-Elements im html das writer_id Attribut des aktuellen Handshift Objekt ist
		p_elem = writer_doc.find('//tei:p[@wID="{}"]'.format(handshift.writer_id), namespaces=namespaces)
		
		# falls ein solches gefunden wurde
		if p_elem is not None:
			
			# Suchen des Listenelement mit der akutellen style_id
			if handshift.style_id:
				list_elem = p_elem.find('.//tei:li[@vID="{}"]'.format(handshift.style_id), namespaces=namespaces)
			
			else:
				# wenn keine style_id existiert, wurde die writer_id verwendet
				list_elem = p_elem.find('.//tei:li[@vID="{}"]'.format(handshift.writer_id), namespaces=namespaces)
			# Test ob ein Listenelement gefunden wurde
			if list_elem is not None:
				# Anhängen des Listeneintrags mit dem Dateipfad, falls ein solcher noch nicht existiert
				if not list_elem.xpath('.//tei:li[text()="{}"]'.format(handshift.source_doc), namespaces=namespaces):
					new_li = etree.Element(etree.QName(tei_ns.uri, 'li'), type='file')
					new_li.text = handshift.source_doc
					list_elem.find('.//tei:ul', namespaces=namespaces).append(new_li)


		else:
			print('No entry with wID = {} was found.'.format(handshift.writer_id))

	# für xhtml das vom Browser verarbeitet werden kann muss die Ausgabe Datei als kanonisches XML geschrieben werden.
	writer_doc.write_c14n('Python_Tutorial_Result.html')
				</code></pre>
					</div>
				</details>
				<br/>
				<p>Das Ergebnis sieht nach dem Ausführen dieses Programms nun so aus:</p>
				<br/>

				<details>
					<summary><b>Ergebnis</b></summary>
					<div class="panel-body">
						<pre>
							<code class="language-html">
<textarea>
...
<!--
	Dies ist nur ein Auschnitt aus der Datei.
	Dort, wo verfügbar wurden die Angaben um den Pfad zu den Quelldokumenten erweitert.
-->
<p type="writer" wID="xx">
	<h4>Fremde Hand #1</h4>
	<ul>
		<li type="variant" vID="bl">
			pencil - Schrift
			<ul type="file_list"></ul>
		</li>
		<li type="variant" vID="bl_gr">
			pencil - greek
			<ul type="file_list"></ul>
		</li>
		<li type="variant" vID="bl_lat">
			pencil - latin
			<ul type="file_list">
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0012.xml</li>
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0013.xml</li>
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0014.xml</li>
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0015.xml</li>
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0016.xml</li>
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0017.xml</li>
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0018.xml</li>
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0019.xml</li>
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0020.xml</li>
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0021.xml</li>
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0022.xml</li>
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0023.xml</li>
				<li type="file">./xml/transcript/agad_warszawa/PL_1_354_13-16-24/0024.xml</li>
			</ul>
		</li>
		<li type="variant" vID="blau">
			blue pencil - Schrift
			<ul type="file_list"></ul>
		</li>
		<li type="variant" vID="blau_gr">
			blue pencil - greek
			<ul type="file_list"></ul>
		</li>
		<li type="variant" vID="blau_lat">
			blue pencil - latin
			<ul type="file_list"></ul>
		</li>
		<li type="variant" vID="ro">
			ruddle - Schrift
			<ul type="file_list"></ul>
		</li>
		<li type="variant" vID="ro_lat">
			ruddle - latin
			<ul type="file_list"></ul>
		</li>
		<li type="variant" vID="t">
			ink - Schrift
			<ul type="file_list"></ul>
		</li>
		<li type="variant" vID="t_gr">
			ink - greek
			<ul type="file_list"></ul>
		</li>
		<li type="variant" vID="t_lat">
			ink - latin
			<ul type="file_list"></ul>
		</li>
		<li type="variant" vID="tr">
			ink red/brown - Schrift
			<ul type="file_list"></ul>
		</li>
		<li type="variant" vID="tr_gr">
			ink red/brown - greek
			<ul type="file_list"></ul>
		</li>
		<li type="variant" vID="tr_lat">
			ink red/brown - latin
			<ul type="file_list"></ul>
		</li>
	</ul>
</p>
...
</textarea>
							</code>
						</pre>
					</div>
				</details>
			</div>
			<br/>


				<div class="panel-body">
					<div class="panel-heading"><h5>Exkurs: Besonderheiten des Datenmodel von lxml</h5></div>
			Da im folgenden Abschnitt die Textdaten der handShift Abschnitte ausgelesen werden, ist es an dieser Stelle nötig den 
			Eigenheiten des lxml-Datenmodels 
			in Bezug auf Textdaten einige Worte zu widmen. Die XML-Spezifikation sieht eigentlich
			vor Text, als Kindelemente (oder Blätter, um in der Baumterminolgie zu bleiben) der Elemente, die ihn enthalten, zu behandeln.<br/>
			Angenommmen wir haben dieses einfach strukturierte XML-Dokument:
			<pre><code class="language-xml">
<textarea>
<dokument>
	<zeile>Ich <verwischt/>einen Satz.</zeile>
</dokument>
</textarea>
</code></pre>
		Wenden wir nun folgenden XPath-Ausdruck:
<pre>
<code class="language-xquery">
//zeile/text()
</code>
</pre>
			auf das Dokument an so erhalten wir eine Sequenz mit den Strings:
<pre>
<code class="language-xquery">
"Ich",
"einen Satz."
</code>
</pre>
			Während man nach dem Ausführen dieses Python-Codes:
<pre>
<code class="language-python">
<textarea>
from lxml import etree

doc = etree.fromstring("""
<dokument>
	<zeile>Ich <verwischt/>einen Satz.</zeile>
</dokument>
""")
elem = doc.find("zeile")
print(elem.text)
</textarea>
</code>
</pre>

			lediglich dieses Resultat bekommt.
<pre>
<code class="language-python">
Ich
</code>
</pre>
			Aber wo ist das Ende des Satzes geblieben?
			lxml unterscheidet hier anhand der Position des Textes. 
			Liegt dieser an erster Stelle, das bedeutet er tritt direkt nach dem Öffnen des Elements auf, wird er dem Element als Attribut <code>text</code> zu geordnet.
			Enthält das Elternelement dieses Texts auch noch andere Elemente, hinter denen weiterer Text liegt, wird dieser den Kindelementen
			zugordnet und ist als Attribut <code>tail</code>
			gespeichert.<br/>
			Um an den gesamten Text zu kommen muss man also alle Geschwisterelemente des Textes bzw. alle Kinder des Elementes, das ihn enthält, auswerten.<br/>
			In unserem Fall zum Beispiel so:
<pre>
<code class="language-python">
<textarea>
from lxml import etree

doc = etree.fromstring("""
<dokument>
	<zeile>Ich <verwischt/>einen Satz.</zeile>
</dokument>
""")
elem = doc.find("zeile")
elem2 = elem.find("verwischt")
print(elem.text)
print(elem2.tail)
</textarea>
</code>
</pre>
			Nun erhalten wir den gesamten Text:
<pre>
<code class="language-python">
Ich
einen Satz.
</code>
</pre>
			Wird XML als Markup verwendet ist es häufig vonnöten, den Text eines Elements und all seiner Nachkommen in der richtigen Reihenfolge zu durchlaufen.
			Eine Möglichkeit dies mit lxml zu bewerkstelligen, ohne XPath zu verwenden, wäre die Verwendung eines rekursiven Algorithmus:
<pre>
<code class="language-python">
def get_text(node):
	if node.text:
		yield node.text
	for child in node.iterchildren():
		yield from get_text(child)
	if node.tail:
		yield node.tail
</code>
</pre>
		Diese Funktion gibt ein Generator-Objekt zurück, dass den Text dann in der korrekten Reihenfolge ausgibt.
		Dafür wird der Teilbaum des übergebenen Elements und all seiner Nachfahren ähnlich der <a href="https://de.wikipedia.org/wiki/Tiefensuche">Tiefensuche</a> durchlaufen.
		Falls vorhanden wird der Inhalt des Text-Attributs des gerade betrachteten Elements ausgegeben, dann werden alle Nachfahren betrachtet.
		Erst wenn diese vollständig abgearbeitet
		worden sind, werden die tail-Attribute in aufsteigender Reihenfolge betrachtet und deren Inhalt ausgegeben. So wird die richtige Reihenfolge des Textes beibehalten.
		In unserem Fall erhalten wir nach dem Ausführen von:
<pre>
<code class="language-python">
<textarea>
from lxml import etree

doc = etree.fromstring("""
<dokument>
	<zeile>Ich <verwischt/>einen Satz.</zeile>
</dokument>
""")

def get_text(node):
	if node.text:
		yield node.text
	for child in node.iterchildren():
		yield from get_text(child)
	if node.tail:
		yield node.tail

print(list(get_text(doc)))
</textarea>
</code>
</pre>
		Den gesamten Text des XML-Dokuments, nebst der Zeilenumbrüche und Whitespaces, die wir vorher ignoriert haben.
<pre>
<code class="language-python">
['\n    ', 'Ich ', 'einen Satz.', '\n']
</code>
</pre>
In dieser Form wird jedoch auch der Text von Kommentarknoten ausgegeben. Um dies zu verhindern muss der Alogrithmus um eine Bedingung erweitert werden:

<pre>
<code class="language-python">
def get_text_without_comments(node):
	if node.text and not isinstance(node, etree._Comment):
			yield node.text
	for child in node.iterchildren():
			yield from get_text_without_comments(child)
	if node.tail:
		yield node.tail
</code>
</pre>
		Hier wird nur der Text des Kommentarknoten, also der eigentliche Kommentar ignoriert. Sonst wird das Element nicht gesondert behandelt,
		denn im <code class="language-python">tail</code> Attribut kann wiederum relevanter Text enthalten sein.
		</p>
		Dieser Algorithmus wird auch in abgewandelter Form im folgenden Beispiel eingesetzt.<br/> Zu beachten ist hier noch die Rekursionstiefe,
		die die zulässige Anzahl von Selbstaufrufen einer Funktion beschränkt. Bei großen Datenmengen könnte dies zu Abbrüchen führen.
		Dieser Fall trat aber bei einem Test mit allen Daten der Faustedition nicht auf. Da Elemente im TEI-Markup nicht über allzu viele 
		Ebenen verschachtelt sind, sollte dies auch für andere Fälle kein Problem darstellen.<br/>

		<div class="panel-heading">
				<h4>Extraktion der Textdaten der handShift-Abschnitte</h4>
		</div>
		<p>
			Im folgenden Beispiel werden die Textdaten der handShift-Abschnitte ausgelesen und in Textdateien geschrieben.
			Dafür wird die Handshift-Klasse aus dem ersten Beispiel um eine Methode <code class="language-python">get_text</code> zur Extraktion der Texte erweitert.
			Diese greift auf eine Hilfsmethode <code class="language-python">_recursive_dfs</code> zurück.
			Des weiteren wird eine zweite Klasse HandshiftWriter implementiert, mit der die zu verarbeitenden XML-Daten ausgewählt werden können
			und die Textdaten geschrieben werden.<br/>
			Zusätzlich wird der Code zum Auslesen der XML-Dateien und dem Erstellen der Handshift-Objekte in einer weiteren Klasse HandshiftFactory ausgelagert.
			Einige Besonderheiten bei der Extraktion der Daten ergeben sich aus den Implikationen des im voherigen Abschnitts besprochenenn lxml-Datenmodell,
			sowie der Tatsache der nicht hierachischen Gliederung der handShift-Daten.</br>
			Um die Texte auszulesen werden die line-Elemente aus dem content-Attribut der Handshift-Objekte betrachtet und deren Text ausgewertet. Hierbei wird auf die Verwendung von XPath verzichtet,
			um die weiteren Möglichkeiten von lxml zu demonstrieren. Auch wird eine Funktionalität implementiert, die es ermöglicht bestimmte Elemente bei diesem Schritt zu 
			ignorieren, also deren Text nicht zu extrahieren.<br/>
			
		



		</p>
		<details>
			<summary>
				<b>Quellcode</b>
			</summary>
			<div class="panel-body">
		<pre><code class="language-python"><textarea>
from lxml import etree
import glob

class Namespace:
	"""
		Klasse um alle den Namen eines Namensraum zu kapseln
	"""
	def __init__(self, name, uri):  
		"""
		Konstruktor
			:param name: Bezeichnung des Namesraum (wird später im namespace-dict von lxml als key verwendet)
			:param uri: URI des Namenraum
		"""   
		self.name = name
		self.uri = uri
	
	def __str__(self):
		"""
		Stringausgabe nach der Konvention für Namensraumprefixe von lxml.Element-Strings
		"""
		return '{' + self.uri + '}'
	
	def __add__(self, other):
		"""
		Verkettet den Namensraumprefix mit einem beliebigen String
			:param other: String der mit dem Namesraumprefix verkettet werden soll.
		"""
		if not isinstance(other, str):
			raise TypeError("Other has to be of type str")
		return self.__str__() + other

class Handshift:
	"""
		Klasse um alle Daten einer handShift-Einheit zu kapseln und zu verarbeiten.
	"""
	def __init__(self, source_doc, element_list):
		"""
		Konstruktor
			:param source_doc: Name des Quelldokuments in dem die handShift-Einheit gefunden wurde
			:param element_list: Liste aller Elemente der handShift-Einheit, das erste Element der Liste muss das handShift-Element sein, mit dem gestart wird
		"""
		# Namensräume der XML-Dokumente
		self.tei_ns = Namespace('tei', 'http://www.tei-c.org/ns/1.0')
		self.genetic_edition_ns = Namespace('geneticEdition', 'http://www.tei-c.org/ns/geneticEditions')
		self.faustedition_ns = Namespace('faustedition', 'http://www.faustedition.net/ns')
		
		# Falls das erste Element der übergebenen Elementenliste kein handShift-Element ist wird ein Fehler geworfen
		if element_list[0].tag != str(self.tei_ns) + 'handShift':
			raise Exception('First element has to be tei:handShift')
		
		self.source_doc = source_doc
		self.handShift = element_list[0]

		# der Wert des new-Attributs hat die Form '#<writerid>_<styleid>' oder '#<writerid>_<styleid>_<stylesuffix>'
		# weshalb hier die Raute weggesch_<styleid>nitten wird und der String beim ersten Unterstrich geteilt wird
		self.new_attrib = self.handShift.attrib['new'][1:]
		if "_" in self.new_attrib:
			ids = self.new_attrib.split('_', 1)
			self.writer_id = ids[0]
			self.style_id = ids[1] 
		else:
			self.writer_id = self.new_attrib
			self.style_id = ''        
		self.content = element_list[1:]

	def _recursive_dfs(self, node: etree.Element, exclude):

		"""
		Hilfsmethode:
		Rekursive Generator-Funktion, durchläuft alle Nachkommen des (->Unterbaum) übergebenenen Elements und gibt den gefunden Text zurück.
			:param node: Knoten der der ausgewertet werden soll
			:param exclude: Liste mit tag Strings von Elementen deren Text nicht zurückgegeben werden soll    
		"""
		# falls das betrachtete Element in exclude enthalten ist wird der akutelle Funktionsaufruf abgebrochen.
		# Dies führt dazu, dass auch alle Nachfahren des ignorierten Element nicht betrachtet werden.
		# Dies kann gerade bei Element, wie choice sehr hilfreich sein 
		if node.tag in exclude:
			return

		# Überprüfe, ob das betrachtete Element text enthält (vgl. Exkurs lxml-Textmodel) und dieser kein Kommentar ist
		if node.text:
			yield node.text and not isinstance(node, etree._Comment):

		# Überprüfe, ob das betrachtete Element Kindelemente hat
		children = list(node.iterchildren())
		for child in children:
			# falls ein Handshift-Element betrachtet wird, kann dies nur das Ende des Abschnitts bedeuten,
			# deshalb wird die Funktion beendet
			if child.tag == self.tei_ns + 'handShift':
				return
			yield from self._recursive_dfs(child, exclude)

		# Überprüfe, ob der Node text im Tail Attribut enthält (s.o.)
		if node.tail:
			yield node.tail

	def get_text(self, exclude=[])->str:
		"""
		Gibt den Text, des handShifts Abschnitts zurück gibt. Dafür werden die ge:line Elemente ausgewertet
			:param exclude=[]: optional, zusätzliche Elemente, deren Text und der Text deren Kinder nicht ausgewertet werden soll
		"""
		string = ''
		# das handShift-Element, welches den Start des Abschnitts markiert wird gesondert behandelt,
		# denn hier möchte man nicht den ganzen Text der Zeile in der es vorkommt bekommt sondern nur den Text der nach dem Auftreten des Elements kommt
		# -> dieser findet im tail-Attribut des Elements und dem gesamten Text aller following-siblings
		if self.handShift.tail:
			string += self.handShift.tail
		siblings = list(self.handShift.itersiblings())
		# Iteration über alle following-siblings
		for i in siblings:
			# Auswerten der following-siblings
			text = self._recursive_dfs(i, exclude)
			string += ''.join(text)
			# äquivalent zu:
			# for s in text:
			#     string += s
			
		# der restliche Inhalt des Abschnitts wird ausgewertet
		for i in self.content:
			if i.tag == self.genetic_edition_ns + 'line':
				text = self._recursive_dfs(i, exclude)
				string += ''.join(text)
		return string         

	
	def __repr__(self):
		"""
		Eindeutige Stringrepräsentation der Objektinstanz
		"""   
		return super().__repr__() + '\n' + self.source_doc + '\n' + self.writer_id + '\n' + str(self.content)

class HandshiftFactory:

	def __init__(self):
		# Definition der Namensräume
		self.tei_ns = Namespace('tei', 'http://www.tei-c.org/ns/1.0')
		self.genetic_edition_ns = Namespace('geneticEdition', 'http://www.tei-c.org/ns/geneticEditions')
		self.faustedition_ns = Namespace('faustedition', 'http://www.faustedition.net/ns')
		self.namespaces = {
			self.tei_ns.name: self.tei_ns.uri,
			self.genetic_edition_ns.name: self.genetic_edition_ns.uri,
			self.faustedition_ns.name: self.faustedition_ns.uri
		}
	
	def _search_xml_files(self, path:str)-> list:
		import glob
		
		if path.endswith('/'):
			path = path[:-1]

		files = glob.glob(path + '/**/*.xml', recursive=True)
		if not files:
			raise Warning('No XML Files were found.')
		return files

	def run(self, path:str)->list:

		"""
		Dursucht alle xml-Dateien im angegebenen Pfad oder eine Einzeldatei nach Handshift Abschnitten und gibt als Liste diese zurück.
			:param path: Pfad zum Ordner oder zu einer Datei
		"""

		if path.endswith('.xml'):
			files = [path]
		else:
			files = self._search_xml_files(path)

		result = []
		for f in files:

			# Im Falle von Fehlern bei Parsen der Dokumente wird eine Fehlermeldung ausgegeben und diese Datei wird übersprungen.
			try:
				doc = etree.parse(f)
			except etree.XMLSyntaxError as e:
				print('WARNING: Could not parse file {}.\n{}\n'.format(f, str(e)))
				continue
			
			# überspringe den aktuellen Schleifendurchlauf, falls das Dokument kein handShift Element enthält
			if not doc.xpath('//tei:handShift', namespaces=self.namespaces):
				continue

			# der doc_iterator enthält alle Elemente des Dokuments in der Textreihenfolge
			doc_iterator = doc.iter()
			
			# das Done-Objekt wird der next-Funktion übergeben, damit diese keinen StopIteration Fehler wirft, wenn der Iterator "leer" ist
			# dies hat den Vorteil, dass man keine Fehlerbehandlung implementieren muss
			done = object()
			
			# das erste Element des Iteratorsa
			elem = next(doc_iterator, done)
			
			# leere Liste wird später die handShift-Abschnitte als sublists enhalten
			total = []

			# in dieser Schleife wird durch das Element iteriert
			while elem is not done:
				# falls das aktuelle Element ein handShift-Element ist
				if elem.tag == self.tei_ns + 'handShift':
					# initialisiert eine die Liste content mit diesem Element
					content = [elem]
					elem = next(doc_iterator, done)
					# diese Schleife wird solange durchlaufen, wie das aktuelle Element kein handShift-Element ist
					# dabei wird das aktuelle Element an die content-Liste angehängt
					while elem is not done and elem.tag != self.tei_ns + 'handShift':
						content.append(elem)
						elem = next(doc_iterator, done)
					# handShift-Abschnitt wird dem Gesamtergebnis angehängt
					total.append(content) 
				else:
					elem = next(doc_iterator, done)

			for sublist in total:
				result.append(Handshift(f, sublist))

		return result
	
class HandshiftWriter:

	@staticmethod
	def write_txt(handshifts:list, destination:str, exclude=[]):
		"""
		Methode um den Text der Handshiftabschnitte als Txt-Datein zu speichern.
		Muster der Dateinamen der Txtdatein ist: <dateiname des Quelldokuements>_<Writer_ID>_<Style_ID>.txt
			:param handshifts: Liste mit den Hanshift-ELementen
			:param destination: Pfad zum Ordner in den, die Txt-Dateiein geschrieben werden sollen
		"""
		import os
		import re
		if not os.path.isdir(destination):
			os.mkdir(destination)
		# dieser regulärer Ausdruck ermöglicht es Pfadangaben zu Datein in den Pfad, dem Dateinamen und die Dateiendung zu zerlegen.
		# eine genaue Erklärung kann unter https://techtavern.wordpress.com/2009/04/06/regex-that-matches-path-filename-and-extension/ gefunden werden
		regex = re.compile(r'^(.*/)?(?:$|(.+?)(?:(\.[^.]*$)|$))')
		for handshift in handshifts:
			source_doc_splitted = re.match(regex, handshift.source_doc)
			source_doc_filename = source_doc_splitted.group(2)
			filename = destination + '/' + '_'.join((source_doc_filename, handshift.writer_id, handshift.style_id)) + '.txt'
			with open(filename, 'w', encoding='UTF-8') as f:
				f.write(handshift.get_text(exclude))
			
			

# Begin des eigentlichen Programmablaufs
if __name__ == '__main__':
	factory = HandshiftFactory()
    # der Ordner "xml/transcript/agad_warszawa" wird nun nach XML-Dateien durchsucht
    # aus diesen werden dann die Handshift-Abschnitte extrahiert
    result = factory.run('xml/transcript/agad_warszawa')
    # die Texte der Abschnitte werden nun in den Ordner "HandShifts" geschrieben
    HandshiftWriter.write_txt(result, 'HandShifts')
		</textarea></code></pre></div>
		</details>
				</div>
		<div class="panel-footer">
			<a href="https://github.com/LennartKeller/faustedition_referat" target="_blank">Hier erhalten Sie die Datei mit dem vollständigen Code</a>
		</div>
			




			
			<div id="4" class="container">
				<div class="page-header">
					<h3>
						<b>Links</b>
					</h3>
				</div>
				<div class="container">
					<p>
						<a href="Platzhalter">XML-Dateien</a>
					</p>
					<p>
						<a href="Platzhalter">Programmeinreichung</a>
					</p>
					<p>
						<a href="https://www.python.org/downloads/">Python</a>
					</p>
					<p>
						<a href="https://notepad-plus-plus.org/download/v7.5.6.html">Notepad++</a>
					</p>
					<p>
						<a href="https://www.oxygenxml.com/xml_editor/download_oxygenxml_editor.html">Oxygen Trial</a>
					</p>
					<!-- <p><a href="">Weitere Links</a><p>-->
					<br/>
				</div>
			</div>
</body>

</html>