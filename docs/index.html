<!doctype html>
<html>
    <head>
		<title>Faustedition Tutorial</title>
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

		<link rel="stylesheet" href="js/highlight/styles/default.css">
		<script src="js/highlight/highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();
		</script>
		<style>
		summary::-webkit-details-marker {
  display: none
}

summary:after {
  content: "+";
  float: left;
  margin-right: 5px;
}

details[open] summary:after {
  content: "-";
}
</style>
    </head>
	
    <body>
        <h1 class="container"><center><b>XML-Tutorial</b></center></h1>
		<div class="container">
			<div class="page-header">
			<h3><b>Inhaltsverzeichnis</b></h3>
			<nav>
			<ul>
			  <li><a href="#1">Grundlegendes</a></li>
			  <li><a href="#2">XQuery</a></li>
			  <li><a href="#3">Python</a></li>
			</ul>
			</nav>
			</div>
		<div>
<!-- GRUNDLEGENDES ab hier-->
		<div id="1" class="container">
			<div class="page-header">
				<h3><b>Grundlegendes</b></h3>
			</div>
		<div>
			<p>Im Folgenden wird Ihnen erklärt, wie Sie außerhalb der Faustedition selbständig mit den zur Verfügung stehenden XML-Dateien der Handschriften arbeiten können und somit tiefer gehende Forschungsfragen klären können. Momentan stehen Ihnen die Codes zu den Varianten der Schreiber und ein Python-Programm zu Verfügung. Weitere Codes folgen. Dieses Tutorial richtet sich sowohl an Programmierlaien als auch an Leute mit Programmiervorkenntnissen. 
			<p>Wählen Sie <a href="platzhalter" target="_blank">hier</a> eine Handschrift aus und laden Sie die XML-Dateien herunter.</p>
			<p>Um mit den Dateien zu arbeiten brauchen einen Text-Editor. Wir empfehlen Ihnen Notepad++. Sie können es <a href="https://notepad-plus-plus.org/download/v7.5.6.html">hier</a> herunterladen.</p>
			<p>Für XQuery brauchen Sie Folgendes</p>
			<p>Für Python brauchen Sie Folgendes<!-- : Laden Sie die neuste Version Python <a href="https://www.python.org/downloads/</p>" target="_blank">hier</a> herunter und installieren Sie es.-->
		</div>
		</div>
		
		
<!-- VALENTINS CODE ab hier-->
		<div id="2" class="container">
			<div class="page-header">
				<h3><b>Schreiber und ihre Varianten</b></h3>
			</div>
		</div>
		<div class="container"> <!-- style="width: 80%; background: lavender;" -->
		<!-- 	<div class="panel-heading">Die Funktionen im Prolog sind von der angegebenen URL übernommen:</div>-->
		Mit diesem Programm können Sie auf einen Blick in den jeweiligen Handschriften herausfinden, welche Schreiber es gibt und welche Varianten ihnen zugeordnet werden. Dies wird mit der Programmiersprache XQuery erreicht.
		<br>
		
		<br>

<!-- XQuery Tut für Fortgeschrittene --> 
		<details><summary><b>Erläuterung des Quellcodes für Fortgeschrittene</b></summary>
			<div class="panel-body">
			Die Funktionen im Prolog sind von der angegebenen URL übernommen:
				<pre>declare namespace functx = "http://www.functx.com";</pre>
			</div>
			<div class="panel-body">Schneidet den Anfang eines strings aus, bis der übergebene regex matched:
			<pre>declare function functx:substring-before-match
( $arg as xs:string? ,
    $regex as xs:string )  as xs:string {

   tokenize($arg,$regex)[1]
 } ;</pre></div>
		<!--copypasteelement:
			<div class="panel-body">
			Erklärung
				<pre>Code</pre>
			</div> -->
			<div class="panel-body">
			Schneidet das Ende eines strings aus, ab dem match mit dem übergebenem regex
				<pre> declare function functx:substring-after-match
  ( $arg as xs:string? ,
    $regex as xs:string )  as xs:string? {

   replace($arg,concat('^.*?',$regex),'')
 } ;</pre>
			</div>
			<div class="panel-body">
			Speichert Liste mit allen handNote Elementen in liste ab:
				<pre>let $liste := //handNote</pre>
			</div>
			<div class="panel-body">
			Speichert für jedes Listenelement den Anfangsstring, der dem Schreibernamen entspricht
				<pre>let $w := for $i in $liste/functx:substring-before-match(text(), '\s\(') return $i</pre>
			</div>
			<div class="panel-body">
			Eliminiert alle Dopplungen und speichert bereinigte Schreiberliste in $wri
				<pre>let $wri := for $i in fn:distinct-values($w) return $i</pre>
			</div>
			<div class="panel-body">
			Bereitet die Ausgabe vor. Für jeden Schreibernamen in der Liste wird der return Block ausgeführt
				<pre>for $writer in $wri</pre>
			</div>
			<div class="panel-body">
			Sortiert diese alphabetisch
				<pre>order by $writer
return </pre>
			</div>
			<div class="panel-body">
			Der Schreibername wird als Überschrift ausgegeben
				<pre>(&lt;h4>{$writer}&lt;/h4>,</pre>
			</div>
			<div class="panel-body">
			Darunter wird eine Liste mit allen zugehörigen Varianten erzeugt
				<pre>    &lt;ul>{</pre>
			</div>
			<div class="panel-body">
			Speichert all die Elemente in der neuen Liste, die in ihrem Schreiber mit dem Schreiber übereinstimmen,
    der zuvor in der Überschrift ausgegeben wurde
				<pre>    let $variantenListeSchreiber := for $i in $liste where /functx:substring-before-match($i/text(), '\s\(')=$writer return $i</pre>
			</div>
			<div class="panel-body">
			Extrahiert für jedes für den Schreiber relevante Element den string in eine Liste, 
    der zwischen Klammern steht und damit die Variante und Sprache beschreibt
				<pre>    let $v := for $i in $variantenListeSchreiber/functx:substring-before-match(functx:substring-after-match(text(), '\s\('), '\)') return $i</pre>
			</div>
			<div class="panel-body">
			ErkEliminiert Dopplungen von Varianten bei einem einzelnen Schreiber und speichert bereinigte Variantenistelärung
				<pre>    let $var := for $i in fn:distinct-values($v) return $i</pre>
			</div>
			<div class="panel-body">
			Iteriert über Variantenliste des aktuellen Autors und erzeugt für jedes Einzelne ein Listenelement
				<pre>    for $variant in $var</pre>
			</div>
			<div class="panel-body">
			sortiert Varianten alphabetisch
				<pre>    order by $variant
    return &lt;li>{$variant}&lt;/li>}
    &lt;/ul>)
}
&lt;/p>
&lt;/html>
</pre>
			</div>
			</details>
			<br>
			<div class="panel-footer">
				<a href = "https://github.com/LennartKeller/faustedition_referat" target="_blank">Hier erhalten Sie den vollständigen Code</a>
			</div>
		</div>
		
		
		
<!-- LENNARTS CODE ab hier-->
		<div id="3"class="container">
			<div class="page-header">
				<h3><b>Python</b></h3>
			</div>
		</div>
		<div class="container"> <!-- style="width: 80%; <!-- background: lavender;"-->
			<div class="panel-heading">Anderes</div>
			<ol>
				<li>Schritt
				<p>beginnen Sie damit etwas zu machen</p>
				<li>Schritt
				<p>profit</p>
			</ol>
			<br>
			<details><summary><b>Erläuterung des Quellcodes für Fortgeschrittene</b></summary>
			<div class="panel-body">
			Teilcode:
				<pre>
					<code class="python">
						# VORWORT:
# Innerhalb der Transkripte sind die einzelnen handschriftlichten Abschnitte durch das TEI-Element handShift gekennzeichnet.
# Dieses zeigt an das ab hier bis zum nächsten Auftreten eines handShift-Elements der Text aus der Feder
# des im @new-Attribut spezifierten Schreibers sind. Der Wert dieses Attribut ist konform der xml:id aus den <handNote-Elemente> im Header,
# so dass eine eindeutige Zuordnung der Abschnitte zu Schreiber und Schreibvariante möglich ist.
# 
# Nicht nur aus philologischer Sicht ist ein Auslesen dieser Daten interessant, sondern auch auch aus weil die Datenstruktur eine 
# kleine Herausforderung darstellt, denn die <handShift>-Elemente sind leer, enhalten also keine Kinder. 
# Die eigentlichen Daten der handShift-Einheit, bilden also keinen Subtree des handShifts-Elements
# den man einfach per XPath addressieren und auslesen könnte.
# Im folgenden Beispiel werden diese Daten ausgelesen und in einer sehr einfachen Art verarbeitet und mit bereits bestehenden Daten aggregiert.
#
# Das folgende Skript kann grob in 3 Abschnitte gegliedert werden, die eigene Teilaufgaben darstellen:

# 1. Definition von einfachen Klassen, in denen die Daten später gespeichert werden.
# => Dies hat den Vorteil, dass im weiteren Programmablauf nicht mehr mit Listen hantiert werden muss, bei denen man auf die Daten nur
# über einen "nicht sprechenden" Index zugreifen kann.

# 2. Auslesen der gesuchten Daten aus mehreren xml-Dateien mithilfe der der Bibliotheken glob und lxml
# ACHTUNG: lxml gehört nicht zum Standardumfang einer Python-Installation, kann aber einfach mit : '$ pip install lxml' nachinstalliert werden.
#  
# 3. Im letzten Schritte werden die Daten dann in die Ergebnis-Datei aus dem ersten Beispiel integriert.
# => Dies führt jedoch dazu, dass diese relativ groß und unübersichtlich wird. Jedoch kann man so gut zeigen,
# wie einfach sich mit Hilfe von lxml xml-Dateien modifizieren lassen.

from lxml import etree
import glob

# Datenklassen

class Namespace:
    """
        Klasse um alle den Namen eines Namensraum zu kapseln
    """
    def __init__(self, name, uri):  
        """
        Konstruktor
            :param name: Bezeichnung des Namesraum (wird später im namespace-dict von lxml als key verwendet)
            :param uri: URI des Namenraum
        """   
        self.name = name
        self.uri = uri
    
    def __str__(self):
        """
            Stringausgabe nach der Konvention für Namensraumprefixe von lxml.Element-Strings
        """
        return '{' + self.uri + '}'

class Handshift:
    """
        Klasse um alle Daten einer handShift-Einheit zu kapseln und zu verarbeiten.
    """
    def __init__(self, source_doc, element_list):
        """
        Konstruktor
            :param source_doc: Name des Quelldokuments in dem die handShift-Einheit gefunden wurde
            :param element_list: Liste aller Elemente der handShift-Einheit, das erste Element der Liste muss das handShift-Element sein, mit dem gestart wird
        """
        # Namensräume der transcript/** Dokumente
        self.tei_ns = Namespace('tei', 'http://www.tei-c.org/ns/1.0')
        self.genetic_edition_ns = Namespace('geneticEdition', 'http://www.tei-c.org/ns/geneticEditions')
        self.faustedition_ns = Namespace('faustedition', 'http://www.faustedition.net/ns')
        
        # Falls das erste Element der übergebenen Elementenliste kein handShift-Element ist wird ein Fehler geworfen
        if element_list[0].tag != str(self.tei_ns) + 'handShift':
            raise Exception('First element has to be tei:handShift')
        
        self.source_doc = source_doc
        self.handShift = element_list[0]
        self.new_attrib = self.handShift.attrib['new'][1:]
        if "_" in self.new_attrib:
            ids = self.new_attrib.split('_', 1)
            self.writer_id = ids[0]
            self.variant_id = ids[1] 
        else:
            self.writer_id = self.new_attrib
            self.variant_id = ''        
        self.content = element_list[1:]
        

    def get_text(self, text_elements=[]):
        """
        Gibt den Text, des handShifts Teils zurück, dafür werden die ge:line Elemente ausgewertet
            :param text_elements=[]: optional, zusätliche Elemente, deren Text auch ausgewertet werden soll
        """   
        string = ''
        # Sonderfall:
        # Falls  sich das handShift-Element in einem Element befindet, das Text enhält muss dieses auch noch ausgelesen werden,
        # da das lxml-Datenmodel keine Textknoten kennt, sondern den Text als Attribut interpretiert
        try:
            handShift_parent = next(self.handShift.iterancestors())
            text = handShift_parent.xpath('text()')[0]
            string += text
        except StopIteration:
            pass
        text_elements.append(str(self.genetic_edition_ns) + 'line')

        # Iteration über alle Element des handShifts-Abschnitts
        for i in self.content:
            # falls das Element für den Text berücksichtigt wird und auch tatsächlich Text enthält, wird dieser an den Ergebnisstring angehängt
            if i.tag in text_elements and i.text:              
                string += i.text + '\n'
        return string
    
    def __repr__(self):
        """
        Eindeutige Stringrepräsentation der Objektinstanz (zur interakitven Auswertung in einer Python-Shell)
        """   
        return super().__repr__() + '\n' + self.source_doc + '\n' + self.writer_id + '\n' + str(self.content)

# Begin des eigentlichen Programmablaufs
if __name__ == '__main__':
    
    # Definition der Namensräume
    tei_ns = Namespace('tei', 'http://www.tei-c.org/ns/1.0')
    genetic_edition_ns = Namespace('geneticEdition', 'http://www.tei-c.org/ns/geneticEditions')
    faustedition_ns = Namespace('faustedition', 'http://www.faustedition.net/ns')

    # lxml-methoden benötigen die Namensräume als dictionary
    namespaces = {
        # falls der TEI-Namespace, der default-namespace sein soll:
        # None: tei_ns.uri,
        tei_ns.name: tei_ns.uri,
        genetic_edition_ns.name: genetic_edition_ns.uri,
        faustedition_ns.name: faustedition_ns.uri
    }

    files = glob.glob('../Referat/xml/transcript/**/*.xml', recursive=True)

    result = []

    for f in files:

        # einige Dokumente enthalten fehlerhafte xml:id Attribute und können nicht geparst werden
        # in diesem Fall wird eine Fehlermeldung ausgegeben
        try:
            doc = etree.parse(f)
        except etree.XMLSyntaxError as e:
            print('WARNING: Could not parse file {}.\n{}\n'.format(f, str(e)))
            continue
        
        # überspringe den aktuellen Schleifendurchlauf, falls das Dokument kein handShift Element enthält
        if not doc.xpath('//tei:handShift', namespaces=namespaces):
            continue

        # der doc_iterator enthält alle Elemente des Dokuments in der Textreihenfolge
        doc_iterator = doc.iter()
        
        # das Done-Objekt wird der next-Funktion übergeben, damit diese keinen StopIteration Fehler wirft, wenn der Iterator "leer" ist
        # dies hat den Vorteil, dass man keine Fehlerbehandlung implementieren muss
        done = object()
        
        # das erste Element des Iteratorsa
        elem = next(doc_iterator, done)
        
        # leere Liste wird später die handShift-Abschnitte als sublists enhalten
        total = []

        # in dieser Schleife wird durch das Element iteriert
        while elem is not done:
            # falls das aktuelle Element ein handShift-Element ist
            if elem.tag == str(tei_ns) + 'handShift':
                # initialisiere eine die Liste content mit diesem Element
                content = [elem]
                elem = next(doc_iterator, done)
                # diese Schleife wird solange durchlaufen, wie das aktuelle Element kein handShift-Element ist
                # dabei wird das aktuelle Element an die content-Liste angehängt
                while elem is not done and elem.tag != str(tei_ns) + 'handShift':
                    content.append(elem)
                    elem = next(doc_iterator, done)
                # handShift-Abschnitt wird dem Gesamtergebniss angehänt
                total.append(content) 
            else:
                elem = next(doc_iterator, done)

        for sublist in total:
            result.append(Handshift(f, sublist))

# Verknüpfen der mit den Daten der Schreibvarianten nach Autor

# Einlesen der Ergebnisses aus Tutorial 1
writer_doc = etree.parse('writerid_variantid_attributes.xml')

# Vorverarbeitungsschritt, jedes li-Element wird ein leeres ul-Element anghängt,
# in das später die Dateinamen geschrieben werden
for li in writer_doc.xpath('//tei:li', namespaces=namespaces):
    li.append(etree.Element(etree.QName(tei_ns.uri, 'ul'), type='file_list'))

# Iteration über alle handShift Objekte aus dem ersten Programmteil
for handshift in result:
    # Suchen des p-Elements im html das writer_id Attribut des aktuellen Handshift Objekt ist
    p_elem = writer_doc.find('//tei:p[@wID="{}"]'.format(handshift.writer_id), namespaces=namespaces)
    
    # falls ein solches gefunden wurde
    if p_elem is not None:
        
        # Suchen des Listenelement mit der akutellen varianten_id
        if handshift.variant_id:
            list_elem = p_elem.find('.//tei:li[@vID="{}"]'.format(handshift.variant_id), namespaces=namespaces)
        
        else:
            # wenn keine variant_id exisitert, wurde die writer_id verwendet
            list_elem = p_elem.find('.//tei:li[@vID="{}"]'.format(handshift.writer_id), namespaces=namespaces)
        
        # Test ob ein Lustenelement gefunden wurde
        if list_elem is not None:

            new_li = etree.Element(etree.QName(tei_ns.uri, 'li'), type='file')
            new_li.text = handshift.source_doc
            if not list_elem.xpath('.//tei:li[text()="{}"]'.format(handshift.source_doc), namespaces=namespaces):
                list_elem.find('.//tei:ul', namespaces=namespaces).append(new_li)


    else:
        print('No entry with wID = {} was found.'.format(handshift.writer_id))

writer_doc.write_c14n('result.xml')
					</code>
				</pre>
			</div>
			</details>
			<br>
			<div class="panel-footer">
				<a href = "https://github.com/LennartKeller/faustedition_referat" target="_blank">Hier erhalten Sie den vollständigen Code</a>
			</div><br>
		</div>
		
    </body>
</html>